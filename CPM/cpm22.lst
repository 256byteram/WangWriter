   1:				
   2:				;**************************************************************
   3:				;*
   4:				;*             C P / M   version   2 . 2
   5:				;*
   6:				;*   Reconstructed from memory image on February 27, 1981
   7:				;*
   8:				;*                by Clark A. Calkins
   9:				;*
  10:				;**************************************************************
  11:				;
  12:				;   Set memory limit here. This is the amount of contigeous
  13:				; ram starting from 0000. CP/M will reside at the end of this space.
  14:				;
  15:     -	0030          	MEM	EQU	48	;for a 62k system (TS802 TEST - WORKS OK).
  16:				;
  17:     -	0003          	IOBYTE	EQU	3	;i/o definition byte.
  18:     -	0004          	TDRIVE	EQU	4	;current drive name and user number.
  19:     -	0005          	ENTRY	EQU	5	;entry point for the cp/m bdos.
  20:     -	005C          	TFCB	EQU	5CH	;default file control block.
  21:     -	0080          	TBUFF	EQU	80H	;i/o buffer and command line storage.
  22:     -	0100          	TBASE	EQU	100H	;transiant program storage area.
  23:				;
  24:				;   Set control character equates.
  25:				;
  26:     -	0003          	CNTRLC	EQU	3	;control-c
  27:     -	0005          	CNTRLE	EQU	05H	;control-e
  28:     -	0008          	BS	EQU	08H	;backspace
  29:     -	0009          	TAB	EQU	09H	;tab
  30:     -	000A          	LF	EQU	0AH	;line feed
  31:     -	000C          	FF	EQU	0CH	;form feed
  32:     -	000D          	CR	EQU	0DH	;carriage return
  33:     -	0010          	CNTRLP	EQU	10H	;control-p
  34:     -	0012          	CNTRLR	EQU	12H	;control-r
  35:     -	0013          	CNTRLS	EQU	13H	;control-s
  36:     -	0015          	CNTRLU	EQU	15H	;control-u
  37:     -	0018          	CNTRLX	EQU	18H	;control-x
  38:     -	001A          	CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
  39:     -	007F          	DEL	EQU	7FH	;rubout
  40:				;
  41:				;   Set origin for CP/M
  42:				;
  43:     -	A400          		ORG	(MEM-7)*1024
  44:				;
  45:    0+10	A400  C35CA7  	CBASE	JMP	COMMAND		;execute command processor (ccp).
  46:   10+10	A403  C358A7  		JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
  47:				
  48:				;
  49:				;   Standard cp/m ccp input buffer. Format is (max length),
  50:				; (actual length), (char #1), (char #2), (char #3), etc.
  51:				;
  52:     -	A406  7F      	INBUFF	DB	127	;length of input buffer.
  53:     -	A407  03      		DB	3	;current length of contents.
  54:     -	A408  44495200		DB	"DIR",0,0,0
	              0000
  55:     -	A40E  20202020		DB	32,32,32,32,32,32,32,32,32,32
	              20202020
	              2020
  56:     -	A418  436F7079		DB	"Copyright"
	              72696768
	              74
  57:     -	A421  20313937		DB	" 1979 (c) by Digital Research      "
	              39202863
	              29206279
	              20446967
	              6974616C
	              20526573
	              65617263
	              68202020
	              202020
  58:     -	A444  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  59:     -	A450  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  60:     -	A45C  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  61:     -	A468  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  62:     -	A474  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
  63:     -	A480  00000000		DB	0,0,0,0,0,0,0,0
	              00000000
  64:     -	A488  08A4    	INPOINT	DW	INBUFF+2;input line pointer
  65:     -	A48A  0000    	NAMEPNT	DW	0	;input line pointer used for error message. Points to
  66:				;			;start of name in error.
  67:				;
  68:				;   Routine to print (A) on the console. All registers used.
  69:				;
  70:   20+5	A48C  5F      	PRINT	MOV	E,A	;setup bdos call.
  71:   25+7	A48D  0E02    		MVI	C,2
  72:   32+10	A48F  C30500  		JMP	ENTRY
  73:				;
  74:				;   Routine to print (A) on the console and to save (BC).
  75:				;
  76:   42+11	A492  C5      	PRINTB	PUSH	B
  77:   53+17	A493  CD8CA4  		CALL	PRINT
  78:   70+10	A496  C1      		POP	B
  79:   80+10	A497  C9      		RET
  80:				;
  81:				;   Routine to send a carriage return, line feed combination
  82:				; to the console.
  83:				;
  84:   90+7	A498  3E0D    	CRLF	MVI	A,CR
  85:   97+17	A49A  CD92A4  		CALL	PRINTB
  86:  114+7	A49D  3E0A    		MVI	A,LF
  87:  121+10	A49F  C392A4  		JMP	PRINTB
  88:				;
  89:				;   Routine to send one space to the console and save (BC).
  90:				;
  91:  131+7	A4A2  3E20    	SPACE	MVI	A,' '
  92:  138+10	A4A4  C392A4  		JMP	PRINTB
  93:				;
  94:				;   Routine to print character string pointed to be (BC) on the
  95:				; console. It must terminate with a null byte.
  96:				;
  97:  148+11	A4A7  C5      	PLINE	PUSH	B
  98:  159+17	A4A8  CD98A4  		CALL	CRLF
  99:  176+10	A4AB  E1      		POP	H
 100:  186+7	A4AC  7E      	PLINE2	MOV	A,M
 101:  193+4	A4AD  B7      		ORA	A
 102:  197+5+6	A4AE  C8      		RZ
 103:  202+5	A4AF  23      		INX	H
 104:  207+11	A4B0  E5      		PUSH	H
 105:  218+17	A4B1  CD8CA4  		CALL	PRINT
 106:  235+10	A4B4  E1      		POP	H
 107:  245+10	A4B5  C3ACA4  		JMP	PLINE2
 108:				;
 109:				;   Routine to reset the disk system.
 110:				;
 111:  255+7	A4B8  0E0D    	RESDSK	MVI	C,13
 112:  262+10	A4BA  C30500  		JMP	ENTRY
 113:				;
 114:				;   Routine to select disk (A).
 115:				;
 116:  272+5	A4BD  5F      	DSKSEL	MOV	E,A
 117:  277+7	A4BE  0E0E    		MVI	C,14
 118:  284+10	A4C0  C30500  		JMP	ENTRY
 119:				;
 120:				;   Routine to call bdos and save the return code. The zero
 121:				; flag is set on a return of 0ffh.
 122:				;
 123:  294+17	A4C3  CD0500  	ENTRY1	CALL	ENTRY
 124:  311+13	A4C6  32EEAB  		STA	RTNCODE	;save return code.
 125:  324+5	A4C9  3C      		INR	A	;set zero if 0ffh returned.
 126:  329+10	A4CA  C9      		RET
 127:				;
 128:				;   Routine to open a file. (DE) must point to the FCB.
 129:				;
 130:  339+7	A4CB  0E0F    	OPEN	MVI	C,15
 131:  346+10	A4CD  C3C3A4  		JMP	ENTRY1
 132:				;
 133:				;   Routine to open file at (FCB).
 134:				;
 135:  356+4	A4D0  AF      	OPENFCB	XRA	A	;clear the record number byte at fcb+32
 136:  360+13	A4D1  32EDAB  		STA	FCB+32
 137:  373+10	A4D4  11CDAB  		LXI	D,FCB
 138:  383+10	A4D7  C3CBA4  		JMP	OPEN
 139:				;
 140:				;   Routine to close a file. (DE) points to FCB.
 141:				;
 142:  393+7	A4DA  0E10    	CLOSE	MVI	C,16
 143:  400+10	A4DC  C3C3A4  		JMP	ENTRY1
 144:				;
 145:				;   Routine to search for the first file with ambigueous name
 146:				; (DE).
 147:				;
 148:  410+7	A4DF  0E11    	SRCHFST	MVI	C,17
 149:  417+10	A4E1  C3C3A4  		JMP	ENTRY1
 150:				;
 151:				;   Search for the next ambigeous file name.
 152:				;
 153:  427+7	A4E4  0E12    	SRCHNXT	MVI	C,18
 154:  434+10	A4E6  C3C3A4  		JMP	ENTRY1
 155:				;
 156:				;   Search for file at (FCB).
 157:				;
 158:  444+10	A4E9  11CDAB  	SRCHFCB	LXI	D,FCB
 159:  454+10	A4EC  C3DFA4  		JMP	SRCHFST
 160:				;
 161:				;   Routine to delete a file pointed to by (DE).
 162:				;
 163:  464+7	A4EF  0E13    	DELETE	MVI	C,19
 164:  471+10	A4F1  C30500  		JMP	ENTRY
 165:				;
 166:				;   Routine to call the bdos and set the zero flag if a zero
 167:				; status is returned.
 168:				;
 169:  481+17	A4F4  CD0500  	ENTRY2	CALL	ENTRY
 170:  498+4	A4F7  B7      		ORA	A	;set zero flag if appropriate.
 171:  502+10	A4F8  C9      		RET
 172:				;
 173:				;   Routine to read the next record from a sequential file.
 174:				; (DE) points to the FCB.
 175:				;
 176:  512+7	A4F9  0E14    	RDREC	MVI	C,20
 177:  519+10	A4FB  C3F4A4  		JMP	ENTRY2
 178:				;
 179:				;   Routine to read file at (FCB).
 180:				;
 181:  529+10	A4FE  11CDAB  	READFCB	LXI	D,FCB
 182:  539+10	A501  C3F9A4  		JMP	RDREC
 183:				;
 184:				;   Routine to write the next record of a sequential file.
 185:				; (DE) points to the FCB.
 186:				;
 187:  549+7	A504  0E15    	WRTREC	MVI	C,21
 188:  556+10	A506  C3F4A4  		JMP	ENTRY2
 189:				;
 190:				;   Routine to create the file pointed to by (DE).
 191:				;
 192:  566+7	A509  0E16    	CREATE	MVI	C,22
 193:  573+10	A50B  C3C3A4  		JMP	ENTRY1
 194:				;
 195:				;   Routine to rename the file pointed to by (DE). Note that
 196:				; the new name starts at (DE+16).
 197:				;
 198:  583+7	A50E  0E17    	RENAM	MVI	C,23
 199:  590+10	A510  C30500  		JMP	ENTRY
 200:				;
 201:				;   Get the current user code.
 202:				;
 203:  600+7	A513  1EFF    	GETUSR	MVI	E,0FFH
 204:				;
 205:				;   Routne to get or set the current user code.
 206:				; If (E) is FF then this is a GET, else it is a SET.
 207:				;
 208:  607+7	A515  0E20    	GETSETUC:MVI	C,32
 209:  614+10	A517  C30500  		JMP	ENTRY
 210:				;
 211:				;   Routine to set the current drive byte at (TDRIVE).
 212:				;
 213:  624+17	A51A  CD13A5  	SETCDRV	CALL	GETUSR	;get user number
 214:  641+4	A51D  87      		ADD	A	;and shift into the upper 4 bits.
 215:  645+4	A51E  87      		ADD	A
 216:  649+4	A51F  87      		ADD	A
 217:  653+4	A520  87      		ADD	A
 218:  657+10	A521  21EFAB  		LXI	H,CDRIVE;now add in the current drive number.
 219:  667+7	A524  B6      		ORA	M
 220:  674+13	A525  320400  		STA	TDRIVE	;and save.
 221:  687+10	A528  C9      		RET
 222:				;
 223:				;   Move currently active drive down to (TDRIVE).
 224:				;
 225:  697+13	A529  3AEFAB  	MOVECD	LDA	CDRIVE
 226:  710+13	A52C  320400  		STA	TDRIVE
 227:  723+10	A52F  C9      		RET
 228:				;
 229:				;   Routine to convert (A) into upper case ascii. Only letters
 230:				; are affected.
 231:				;
 232:  733+7	A530  FE61    	UPPER	CPI	'a'	;check for letters in the range of 'a' to 'z'.
 233:  740+5+6	A532  D8      		RC
 234:  745+7	A533  FE7B    		CPI	'{'
 235:  752+5+6	A535  D0      		RNC
 236:  757+7	A536  E65F    		ANI	5FH	;convert it if found.
 237:  764+10	A538  C9      		RET
 238:				;
 239:				;   Routine to get a line of input. We must check to see if the
 240:				; user is in (BATCH) mode. If so, then read the input from file
 241:				; ($$$.SUB). At the end, reset to console input.
 242:				;
 243:  774+13	A539  3AABAB  	GETINP	LDA	BATCH	;if =0, then use console input.
 244:  787+4	A53C  B7      		ORA	A
 245:  791+10	A53D  CA96A5  		JZ	GETINP1
 246:				;
 247:				;   Use the submit file ($$$.sub) which is prepared by a
 248:				; SUBMIT run. It must be on drive (A) and it will be deleted
 249:				; if and error occures (like eof).
 250:				;
 251:  801+13	A540  3AEFAB  		LDA	CDRIVE	;select drive 0 if need be.
 252:  814+4	A543  B7      		ORA	A
 253:  818+7	A544  3E00    		MVI	A,0	;always use drive A for submit.
 254:  825+11+6	A546  C4BDA4  		CNZ	DSKSEL	;select it if required.
 255:  836+10	A549  11ACAB  		LXI	D,BATCHFCB
 256:  846+17	A54C  CDCBA4  		CALL	OPEN	;look for it.
 257:  863+10	A54F  CA96A5  		JZ	GETINP1	;if not there, use normal input.
 258:  873+13	A552  3ABBAB  		LDA	BATCHFCB+15;get last record number+1.
 259:  886+5	A555  3D      		DCR	A
 260:  891+13	A556  32CCAB  		STA	BATCHFCB+32
 261:  904+10	A559  11ACAB  		LXI	D,BATCHFCB
 262:  914+17	A55C  CDF9A4  		CALL	RDREC	;read last record.
 263:  931+10	A55F  C296A5  		JNZ	GETINP1	;quit on end of file.
 264:				;
 265:				;   Move this record into input buffer.
 266:				;
 267:  941+10	A562  1107A4  		LXI	D,INBUFF+1
 268:  951+10	A565  218000  		LXI	H,TBUFF	;data was read into buffer here.
 269:  961+7	A568  0680    		MVI	B,128	;all 128 characters may be used.
 270:  968+17	A56A  CD42A8  		CALL	HL2DE	;(HL) to (DE), (B) bytes.
 271:  985+10	A56D  21BAAB  		LXI	H,BATCHFCB+14
 272:  995+10	A570  3600    		MVI	M,0	;zero out the 's2' byte.
 273: 1005+5	A572  23      		INX	H	;and decrement the record count.
 274: 1010+10	A573  35      		DCR	M
 275: 1020+10	A574  11ACAB  		LXI	D,BATCHFCB;close the batch file now.
 276: 1030+17	A577  CDDAA4  		CALL	CLOSE
 277: 1047+10	A57A  CA96A5  		JZ	GETINP1	;quit on an error.
 278: 1057+13	A57D  3AEFAB  		LDA	CDRIVE	;re-select previous drive if need be.
 279: 1070+4	A580  B7      		ORA	A
 280: 1074+11+6	A581  C4BDA4  		CNZ	DSKSEL	;don't do needless selects.
 281:				;
 282:				;   Print line just read on console.
 283:				;
 284: 1085+10	A584  2108A4  		LXI	H,INBUFF+2
 285: 1095+17	A587  CDACA4  		CALL	PLINE2
 286: 1112+17	A58A  CDC2A5  		CALL	CHKCON	;check console, quit on a key.
 287: 1129+10	A58D  CAA7A5  		JZ	GETINP2	;jump if no key is pressed.
 288:				;
 289:				;   Terminate the submit job on any keyboard input. Delete this
 290:				; file such that it is not re-started and jump to normal keyboard
 291:				; input section.
 292:				;
 293: 1139+17	A590  CDDDA5  		CALL	DELBATCH;delete the batch file.
 294: 1156+10	A593  C382A7  		JMP	CMMND1	;and restart command input.
 295:				;
 296:				;   Get here for normal keyboard input. Delete the submit file
 297:				; incase there was one.
 298:				;
 299: 1166+17	A596  CDDDA5  	GETINP1	CALL	DELBATCH;delete file ($$$.sub).
 300: 1183+17	A599  CD1AA5  		CALL	SETCDRV	;reset active disk.
 301: 1200+7	A59C  0E0A    		MVI	C,10	;get line from console device.
 302: 1207+10	A59E  1106A4  		LXI	D,INBUFF
 303: 1217+17	A5A1  CD0500  		CALL	ENTRY
 304: 1234+17	A5A4  CD29A5  		CALL	MOVECD	;reset current drive (again).
 305:				;
 306:				;   Convert input line to upper case.
 307:				;
 308: 1251+10	A5A7  2107A4  	GETINP2	LXI	H,INBUFF+1
 309: 1261+7	A5AA  46      		MOV	B,M	;(B)=character counter.
 310: 1268+5	A5AB  23      	GETINP3	INX	H
 311: 1273+5	A5AC  78      		MOV	A,B	;end of the line?
 312: 1278+4	A5AD  B7      		ORA	A
 313: 1282+10	A5AE  CABAA5  		JZ	GETINP4
 314: 1292+7	A5B1  7E      		MOV	A,M	;convert to upper case.
 315: 1299+17	A5B2  CD30A5  		CALL	UPPER
 316: 1316+7	A5B5  77      		MOV	M,A
 317: 1323+5	A5B6  05      		DCR	B	;adjust character count.
 318: 1328+10	A5B7  C3ABA5  		JMP	GETINP3
 319: 1338+7	A5BA  77      	GETINP4	MOV	M,A	;add trailing null.
 320: 1345+10	A5BB  2108A4  		LXI	H,INBUFF+2
 321: 1355+16	A5BE  2288A4  		SHLD	INPOINT	;reset input line pointer.
 322: 1371+10	A5C1  C9      		RET
 323:				;
 324:				;   Routine to check the console for a key pressed. The zero
 325:				; flag is set is none, else the character is returned in (A).
 326:				;
 327: 1381+7	A5C2  0E0B    	CHKCON	MVI	C,11	;check console.
 328: 1388+17	A5C4  CD0500  		CALL	ENTRY
 329: 1405+4	A5C7  B7      		ORA	A
 330: 1409+5+6	A5C8  C8      		RZ		;return if nothing.
 331: 1414+7	A5C9  0E01    		MVI	C,1	;else get character.
 332: 1421+17	A5CB  CD0500  		CALL	ENTRY
 333: 1438+4	A5CE  B7      		ORA	A	;clear zero flag and return.
 334: 1442+10	A5CF  C9      		RET
 335:				;
 336:				;   Routine to get the currently active drive number.
 337:				;
 338: 1452+7	A5D0  0E19    	GETDSK	MVI	C,25
 339: 1459+10	A5D2  C30500  		JMP	ENTRY
 340:				;
 341:				;   Set the stabdard dma address.
 342:				;
 343: 1469+10	A5D5  118000  	STDDMA	LXI	D,TBUFF
 344:				;
 345:				;   Routine to set the dma address to (DE).
 346:				;
 347: 1479+7	A5D8  0E1A    	DMASET	MVI	C,26
 348: 1486+10	A5DA  C30500  		JMP	ENTRY
 349:				;
 350:				;  Delete the batch file created by SUBMIT.
 351:				;
 352: 1496+10	A5DD  21ABAB  	DELBATCH:LXI	H,BATCH	;is batch active?
 353: 1506+7	A5E0  7E      		MOV	A,M
 354: 1513+4	A5E1  B7      		ORA	A
 355: 1517+5+6	A5E2  C8      		RZ
 356: 1522+10	A5E3  3600    		MVI	M,0	;yes, de-activate it.
 357: 1532+4	A5E5  AF      		XRA	A
 358: 1536+17	A5E6  CDBDA4  		CALL	DSKSEL	;select drive 0 for sure.
 359: 1553+10	A5E9  11ACAB  		LXI	D,BATCHFCB;and delete this file.
 360: 1563+17	A5EC  CDEFA4  		CALL	DELETE
 361: 1580+13	A5EF  3AEFAB  		LDA	CDRIVE	;reset current drive.
 362: 1593+10	A5F2  C3BDA4  		JMP	DSKSEL
 363:				;
 364:				;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
 365:				; the same or we halt....
 366:				;
 367: 1603+10	A5F5  1128A7  	VERIFY	LXI	D,PATTRN1;these are the serial number bytes.
 368: 1613+10	A5F8  2100AC  		LXI	H,PATTRN2;ditto, but how could they be different?
 369: 1623+7	A5FB  0606    		MVI	B,6	;6 bytes each.
 370: 1630+7	A5FD  1A      	VERIFY1	LDAX	D
 371: 1637+7	A5FE  BE      		CMP	M
 372: 1644+10	A5FF  C2CFA7  		JNZ	HALT	;jump to halt routine.
 373: 1654+5	A602  13      		INX	D
 374: 1659+5	A603  23      		INX	H
 375: 1664+5	A604  05      		DCR	B
 376: 1669+10	A605  C2FDA5  		JNZ	VERIFY1
 377: 1679+10	A608  C9      		RET
 378:				;
 379:				;   Print back file name with a '?' to indicate a syntax error.
 380:				;
 381: 1689+17	A609  CD98A4  	SYNERR	CALL	CRLF	;end current line.
 382: 1706+16	A60C  2A8AA4  		LHLD	NAMEPNT	;this points to name in error.
 383: 1722+7	A60F  7E      	SYNERR1	MOV	A,M	;print it until a space or null is found.
 384: 1729+7	A610  FE20    		CPI	' '
 385: 1736+10	A612  CA22A6  		JZ	SYNERR2
 386: 1746+4	A615  B7      		ORA	A
 387: 1750+10	A616  CA22A6  		JZ	SYNERR2
 388: 1760+11	A619  E5      		PUSH	H
 389: 1771+17	A61A  CD8CA4  		CALL	PRINT
 390: 1788+10	A61D  E1      		POP	H
 391: 1798+5	A61E  23      		INX	H
 392: 1803+10	A61F  C30FA6  		JMP	SYNERR1
 393: 1813+7	A622  3E3F    	SYNERR2	MVI	A,'?'	;add trailing '?'.
 394: 1820+17	A624  CD8CA4  		CALL	PRINT
 395: 1837+17	A627  CD98A4  		CALL	CRLF
 396: 1854+17	A62A  CDDDA5  		CALL	DELBATCH;delete any batch file.
 397: 1871+10	A62D  C382A7  		JMP	CMMND1	;and restart from console input.
 398:				;
 399:				;   Check character at (DE) for legal command input. Note that the
 400:				; zero flag is set if the character is a delimiter.
 401:				;
 402: 1881+7	A630  1A      	CHECK	LDAX	D
 403: 1888+4	A631  B7      		ORA	A
 404: 1892+5+6	A632  C8      		RZ
 405: 1897+7	A633  FE20    		CPI	' '	;control characters are not legal here.
 406: 1904+10	A635  DA09A6  		JC	SYNERR
 407: 1914+5+6	A638  C8      		RZ		;check for valid delimiter.
 408: 1919+7	A639  FE3D    		CPI	'='
 409: 1926+5+6	A63B  C8      		RZ
 410: 1931+7	A63C  FE5F    		CPI	'_'
 411: 1938+5+6	A63E  C8      		RZ
 412: 1943+7	A63F  FE2E    		CPI	'.'
 413: 1950+5+6	A641  C8      		RZ
 414: 1955+7	A642  FE3A    		CPI	':'
 415: 1962+5+6	A644  C8      		RZ
 416: 1967+7	A645  FE3B    		CPI	';'
 417: 1974+5+6	A647  C8      		RZ
 418: 1979+7	A648  FE3C    		CPI	'<'
 419: 1986+5+6	A64A  C8      		RZ
 420: 1991+7	A64B  FE3E    		CPI	'>'
 421: 1998+5+6	A64D  C8      		RZ
 422: 2003+10	A64E  C9      		RET
 423:				;
 424:				;   Get the next non-blank character from (DE).
 425:				;
 426: 2013+7	A64F  1A      	NONBLANK:LDAX	D
 427: 2020+4	A650  B7      		ORA	A	;string ends with a null.
 428: 2024+5+6	A651  C8      		RZ
 429: 2029+7	A652  FE20    		CPI	' '
 430: 2036+5+6	A654  C0      		RNZ
 431: 2041+5	A655  13      		INX	D
 432: 2046+10	A656  C34FA6  		JMP	NONBLANK
 433:				;
 434:				;   Add (HL)=(HL)+(A)
 435:				;
 436: 2056+4	A659  85      	ADDHL	ADD	L
 437: 2060+5	A65A  6F      		MOV	L,A
 438: 2065+5+6	A65B  D0      		RNC	;take care of any carry.
 439: 2070+5	A65C  24      		INR	H
 440: 2075+10	A65D  C9      		RET
 441:				;
 442:				;   Convert the first name in (FCB).
 443:				;
 444: 2085+7	A65E  3E00    	CONVFST	MVI	A,0
 445:				;
 446:				;   Format a file name (convert * to '?', etc.). On return,
 447:				; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
 448:				; the position within the fcb for the name (either 0 or 16).
 449:				;
 450: 2092+10	A660  21CDAB  	CONVERT	LXI	H,FCB
 451: 2102+17	A663  CD59A6  		CALL	ADDHL
 452: 2119+11	A666  E5      		PUSH	H
 453: 2130+11	A667  E5      		PUSH	H
 454: 2141+4	A668  AF      		XRA	A
 455: 2145+13	A669  32F0AB  		STA	CHGDRV	;initialize drive change flag.
 456: 2158+16	A66C  2A88A4  		LHLD	INPOINT	;set (HL) as pointer into input line.
 457: 2174+4	A66F  EB      		XCHG
 458: 2178+17	A670  CD4FA6  		CALL	NONBLANK;get next non-blank character.
 459: 2195+4	A673  EB      		XCHG
 460: 2199+16	A674  228AA4  		SHLD	NAMEPNT	;save pointer here for any error message.
 461: 2215+4	A677  EB      		XCHG
 462: 2219+10	A678  E1      		POP	H
 463: 2229+7	A679  1A      		LDAX	D	;get first character.
 464: 2236+4	A67A  B7      		ORA	A
 465: 2240+10	A67B  CA89A6  		JZ	CONVRT1
 466: 2250+7	A67E  DE40    		SBI	'A'-1	;might be a drive name, convert to binary.
 467: 2257+5	A680  47      		MOV	B,A	;and save.
 468: 2262+5	A681  13      		INX	D	;check next character for a ':'.
 469: 2267+7	A682  1A      		LDAX	D
 470: 2274+7	A683  FE3A    		CPI	':'
 471: 2281+10	A685  CA90A6  		JZ	CONVRT2
 472: 2291+5	A688  1B      		DCX	D	;nope, move pointer back to the start of the line.
 473: 2296+13	A689  3AEFAB  	CONVRT1	LDA	CDRIVE
 474: 2309+7	A68C  77      		MOV	M,A
 475: 2316+10	A68D  C396A6  		JMP	CONVRT3
 476: 2326+5	A690  78      	CONVRT2	MOV	A,B
 477: 2331+13	A691  32F0AB  		STA	CHGDRV	;set change in drives flag.
 478: 2344+7	A694  70      		MOV	M,B
 479: 2351+5	A695  13      		INX	D
 480:				;
 481:				;   Convert the basic file name.
 482:				;
 483: 2356+7	A696  0608    	CONVRT3	MVI	B,08H
 484: 2363+17	A698  CD30A6  	CONVRT4	CALL	CHECK
 485: 2380+10	A69B  CAB9A6  		JZ	CONVRT8
 486: 2390+5	A69E  23      		INX	H
 487: 2395+7	A69F  FE2A    		CPI	'*'	;note that an '*' will fill the remaining
 488: 2402+10	A6A1  C2A9A6  		JNZ	CONVRT5	;field with '?'.
 489: 2412+10	A6A4  363F    		MVI	M,'?'
 490: 2422+10	A6A6  C3ABA6  		JMP	CONVRT6
 491: 2432+7	A6A9  77      	CONVRT5	MOV	M,A
 492: 2439+5	A6AA  13      		INX	D
 493: 2444+5	A6AB  05      	CONVRT6	DCR	B
 494: 2449+10	A6AC  C298A6  		JNZ	CONVRT4
 495: 2459+17	A6AF  CD30A6  	CONVRT7	CALL	CHECK	;get next delimiter.
 496: 2476+10	A6B2  CAC0A6  		JZ	GETEXT
 497: 2486+5	A6B5  13      		INX	D
 498: 2491+10	A6B6  C3AFA6  		JMP	CONVRT7
 499: 2501+5	A6B9  23      	CONVRT8	INX	H	;blank fill the file name.
 500: 2506+10	A6BA  3620    		MVI	M,' '
 501: 2516+5	A6BC  05      		DCR	B
 502: 2521+10	A6BD  C2B9A6  		JNZ	CONVRT8
 503:				;
 504:				;   Get the extension and convert it.
 505:				;
 506: 2531+7	A6C0  0603    	GETEXT	MVI	B,03H
 507: 2538+7	A6C2  FE2E    		CPI	'.'
 508: 2545+10	A6C4  C2E9A6  		JNZ	GETEXT5
 509: 2555+5	A6C7  13      		INX	D
 510: 2560+17	A6C8  CD30A6  	GETEXT1	CALL	CHECK
 511: 2577+10	A6CB  CAE9A6  		JZ	GETEXT5
 512: 2587+5	A6CE  23      		INX	H
 513: 2592+7	A6CF  FE2A    		CPI	'*'
 514: 2599+10	A6D1  C2D9A6  		JNZ	GETEXT2
 515: 2609+10	A6D4  363F    		MVI	M,'?'
 516: 2619+10	A6D6  C3DBA6  		JMP	GETEXT3
 517: 2629+7	A6D9  77      	GETEXT2	MOV	M,A
 518: 2636+5	A6DA  13      		INX	D
 519: 2641+5	A6DB  05      	GETEXT3	DCR	B
 520: 2646+10	A6DC  C2C8A6  		JNZ	GETEXT1
 521: 2656+17	A6DF  CD30A6  	GETEXT4	CALL	CHECK
 522: 2673+10	A6E2  CAF0A6  		JZ	GETEXT6
 523: 2683+5	A6E5  13      		INX	D
 524: 2688+10	A6E6  C3DFA6  		JMP	GETEXT4
 525: 2698+5	A6E9  23      	GETEXT5	INX	H
 526: 2703+10	A6EA  3620    		MVI	M,' '
 527: 2713+5	A6EC  05      		DCR	B
 528: 2718+10	A6ED  C2E9A6  		JNZ	GETEXT5
 529: 2728+7	A6F0  0603    	GETEXT6	MVI	B,3
 530: 2735+5	A6F2  23      	GETEXT7	INX	H
 531: 2740+10	A6F3  3600    		MVI	M,0
 532: 2750+5	A6F5  05      		DCR	B
 533: 2755+10	A6F6  C2F2A6  		JNZ	GETEXT7
 534: 2765+4	A6F9  EB      		XCHG
 535: 2769+16	A6FA  2288A4  		SHLD	INPOINT	;save input line pointer.
 536: 2785+10	A6FD  E1      		POP	H
 537:				;
 538:				;   Check to see if this is an ambigeous file name specification.
 539:				; Set the (A) register to non zero if it is.
 540:				;
 541: 2795+10	A6FE  010B00  		LXI	B,11	;set name length.
 542: 2805+5	A701  23      	GETEXT8	INX	H
 543: 2810+7	A702  7E      		MOV	A,M
 544: 2817+7	A703  FE3F    		CPI	'?'	;any question marks?
 545: 2824+10	A705  C209A7  		JNZ	GETEXT9
 546: 2834+5	A708  04      		INR	B	;count them.
 547: 2839+5	A709  0D      	GETEXT9	DCR	C
 548: 2844+10	A70A  C201A7  		JNZ	GETEXT8
 549: 2854+5	A70D  78      		MOV	A,B
 550: 2859+4	A70E  B7      		ORA	A
 551: 2863+10	A70F  C9      		RET
 552:				;
 553:				;   CP/M command table. Note commands can be either 3 or 4 characters long.
 554:				;
 555:     -	0006          	NUMCMDS	EQU	6	;number of commands
 556:     -	A710  44495220	CMDTBL	DB	"DIR "
 557:     -	A714  45524120		DB	"ERA "
 558:     -	A718  54595045		DB	"TYPE"
 559:     -	A71C  53415645		DB	"SAVE"
 560:     -	A720  52454E20		DB	"REN "
 561:     -	A724  55534552		DB	"USER"
 562:				
 563:				;   The following six bytes must agree with those at (PATTRN2)
 564:				; or cp/m will HALT. Why?
 565:				;
 566:     -	A728  00160000	PATTRN1	DB	0,22,0,0,0,0;(* serial number bytes *).
	              0000
 567:				;
 568:				;   Search the command table for a match with what has just
 569:				; been entered. If a match is found, then we jump to the
 570:				; proper section. Else jump to (UNKNOWN).
 571:				; On return, the (C) register is set to the command number
 572:				; that matched (or NUMCMDS+1 if no match).
 573:				;
 574: 2873+10	A72E  2110A7  	SEARCH	LXI	H,CMDTBL
 575: 2883+7	A731  0E00    		MVI	C,0
 576: 2890+5	A733  79      	SEARCH1	MOV	A,C
 577: 2895+7	A734  FE06    		CPI	NUMCMDS	;this commands exists.
 578: 2902+5+6	A736  D0      		RNC
 579: 2907+10	A737  11CEAB  		LXI	D,FCB+1	;check this one.
 580: 2917+7	A73A  0604    		MVI	B,4	;max command length.
 581: 2924+7	A73C  1A      	SEARCH2	LDAX	D
 582: 2931+7	A73D  BE      		CMP	M
 583: 2938+10	A73E  C24FA7  		JNZ	SEARCH3	;not a match.
 584: 2948+5	A741  13      		INX	D
 585: 2953+5	A742  23      		INX	H
 586: 2958+5	A743  05      		DCR	B
 587: 2963+10	A744  C23CA7  		JNZ	SEARCH2
 588: 2973+7	A747  1A      		LDAX	D	;allow a 3 character command to match.
 589: 2980+7	A748  FE20    		CPI	' '
 590: 2987+10	A74A  C254A7  		JNZ	SEARCH4
 591: 2997+5	A74D  79      		MOV	A,C	;set return register for this command.
 592: 3002+10	A74E  C9      		RET
 593: 3012+5	A74F  23      	SEARCH3	INX	H
 594: 3017+5	A750  05      		DCR	B
 595: 3022+10	A751  C24FA7  		JNZ	SEARCH3
 596: 3032+5	A754  0C      	SEARCH4	INR	C
 597: 3037+10	A755  C333A7  		JMP	SEARCH1
 598:				;
 599:				;   Set the input buffer to empty and then start the command
 600:				; processor (ccp).
 601:				;
 602: 3047+4	A758  AF      	CLEARBUF:XRA	A
 603: 3051+13	A759  3207A4  		STA	INBUFF+1;second byte is actual length.
 604:				;
 605:				;**************************************************************
 606:				;*
 607:				;*
 608:				;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
 609:				;*
 610:				;**************************************************************
 611:				;*
 612: 3064+10	A75C  31ABAB  	COMMAND	LXI	SP,CCPSTACK;setup stack area.
 613: 3074+11	A75F  C5      		PUSH	B	;note that (C) should be equal to:
 614: 3085+5	A760  79      		MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
 615: 3090+4	A761  1F      		RAR		;and 'dddd' is the drive number.
 616: 3094+4	A762  1F      		RAR
 617: 3098+4	A763  1F      		RAR
 618: 3102+4	A764  1F      		RAR
 619: 3106+7	A765  E60F    		ANI	0FH	;isolate the user number.
 620: 3113+5	A767  5F      		MOV	E,A
 621: 3118+17	A768  CD15A5  		CALL	GETSETUC;and set it.
 622: 3135+17	A76B  CDB8A4  		CALL	RESDSK	;reset the disk system.
 623: 3152+13	A76E  32ABAB  		STA	BATCH	;clear batch mode flag.
 624: 3165+10	A771  C1      		POP	B
 625: 3175+5	A772  79      		MOV	A,C
 626: 3180+7	A773  E60F    		ANI	0FH	;isolate the drive number.
 627: 3187+13	A775  32EFAB  		STA	CDRIVE	;and save.
 628: 3200+17	A778  CDBDA4  		CALL	DSKSEL	;...and select.
 629: 3217+13	A77B  3A07A4  		LDA	INBUFF+1
 630: 3230+4	A77E  B7      		ORA	A	;anything in input buffer already?
 631: 3234+10	A77F  C298A7  		JNZ	CMMND2	;yes, we just process it.
 632:				;
 633:				;   Entry point to get a command line from the console.
 634:				;
 635: 3244+10	A782  31ABAB  	CMMND1	LXI	SP,CCPSTACK;set stack straight.
 636: 3254+17	A785  CD98A4  		CALL	CRLF	;start a new line on the screen.
 637: 3271+17	A788  CDD0A5  		CALL	GETDSK	;get current drive.
 638: 3288+7	A78B  C661    		ADI	'a'
 639: 3295+17	A78D  CD8CA4  		CALL	PRINT	;print current drive.
 640: 3312+7	A790  3E3E    		MVI	A,'>'
 641: 3319+17	A792  CD8CA4  		CALL	PRINT	;and add prompt.
 642: 3336+17	A795  CD39A5  		CALL	GETINP	;get line from user.
 643:				;
 644:				;   Process command line here.
 645:				;
 646: 3353+10	A798  118000  	CMMND2	LXI	D,TBUFF
 647: 3363+17	A79B  CDD8A5  		CALL	DMASET	;set standard dma address.
 648: 3380+17	A79E  CDD0A5  		CALL	GETDSK
 649: 3397+13	A7A1  32EFAB  		STA	CDRIVE	;set current drive.
 650: 3410+17	A7A4  CD5EA6  		CALL	CONVFST	;convert name typed in.
 651: 3427+11+6	A7A7  C409A6  		CNZ	SYNERR	;wild cards are not allowed.
 652: 3438+13	A7AA  3AF0AB  		LDA	CHGDRV	;if a change in drives was indicated,
 653: 3451+4	A7AD  B7      		ORA	A	;then treat this as an unknown command
 654: 3455+10	A7AE  C2A5AA  		JNZ	UNKNOWN	;which gets executed.
 655: 3465+17	A7B1  CD2EA7  		CALL	SEARCH	;else search command table for a match.
 656:				;
 657:				;   Note that an unknown command returns
 658:				; with (A) pointing to the last address
 659:				; in our table which is (UNKNOWN).
 660:				;
 661: 3482+10	A7B4  21C1A7  		LXI	H,CMDADR;now, look thru our address table for command (A).
 662: 3492+5	A7B7  5F      		MOV	E,A	;set (DE) to command number.
 663: 3497+7	A7B8  1600    		MVI	D,0
 664: 3504+10	A7BA  19      		DAD	D
 665: 3514+10	A7BB  19      		DAD	D	;(HL)=(CMDADR)+2*(command number).
 666: 3524+7	A7BC  7E      		MOV	A,M	;now pick out this address.
 667: 3531+5	A7BD  23      		INX	H
 668: 3536+7	A7BE  66      		MOV	H,M
 669: 3543+5	A7BF  6F      		MOV	L,A
 670: 3548+5	A7C0  E9      		PCHL		;now execute it.
 671:				;
 672:				;   CP/M command address table.
 673:				;
 674:     -	A7C1  77A81FA9	CMDADR	DW	DIRECT,ERASE,TYPE,SAVE
	              5DA9ADA9
 675:     -	A7C9  10AA8EAA		DW	RENAME,USER,UNKNOWN
	              A5AA
 676:				;
 677:				;   Halt the system. Reason for this is unknown at present.
 678:				;
 679: 3553+10	A7CF  21F376  	HALT	LXI	H,76F3H	;'DI HLT' instructions.
 680: 3563+16	A7D2  2200A4  		SHLD	CBASE
 681: 3579+10	A7D5  2100A4  		LXI	H,CBASE
 682: 3589+5	A7D8  E9      		PCHL
 683:				;
 684:				;   Read error while TYPEing a file.
 685:				;
 686: 3594+10	A7D9  01DFA7  	RDERROR	LXI	B,RDERR
 687: 3604+10	A7DC  C3A7A4  		JMP	PLINE
 688:     -	A7DF  52656164	RDERR	DB	"Read error",0
	              20657272
	              6F7200
 689:				;
 690:				;   Required file was not located.
 691:				;
 692: 3614+10	A7EA  01F0A7  	NONE	LXI	B,NOFILE
 693: 3624+10	A7ED  C3A7A4  		JMP	PLINE
 694:     -	A7F0  4E6F2066	NOFILE	DB	"No file",0
	              696C6500
 695:				;
 696:				;   Decode a command of the form 'A>filename number{ filename}.
 697:				; Note that a drive specifier is not allowed on the first file
 698:				; name. On return, the number is in register (A). Any error
 699:				; causes 'filename?' to be printed and the command is aborted.
 700:				;
 701: 3634+17	A7F8  CD5EA6  	DECODE	CALL	CONVFST	;convert filename.
 702: 3651+13	A7FB  3AF0AB  		LDA	CHGDRV	;do not allow a drive to be specified.
 703: 3664+4	A7FE  B7      		ORA	A
 704: 3668+10	A7FF  C209A6  		JNZ	SYNERR
 705: 3678+10	A802  21CEAB  		LXI	H,FCB+1	;convert number now.
 706: 3688+10	A805  010B00  		LXI	B,11	;(B)=sum register, (C)=max digit count.
 707: 3698+7	A808  7E      	DECODE1	MOV	A,M
 708: 3705+7	A809  FE20    		CPI	' '	;a space terminates the numeral.
 709: 3712+10	A80B  CA33A8  		JZ	DECODE3
 710: 3722+5	A80E  23      		INX	H
 711: 3727+7	A80F  D630    		SUI	'0'	;make binary from ascii.
 712: 3734+7	A811  FE0A    		CPI	10	;legal digit?
 713: 3741+10	A813  D209A6  		JNC	SYNERR
 714: 3751+5	A816  57      		MOV	D,A	;yes, save it in (D).
 715: 3756+5	A817  78      		MOV	A,B	;compute (B)=(B)*10 and check for overflow.
 716: 3761+7	A818  E6E0    		ANI	0E0H
 717: 3768+10	A81A  C209A6  		JNZ	SYNERR
 718: 3778+5	A81D  78      		MOV	A,B
 719: 3783+4	A81E  07      		RLC
 720: 3787+4	A81F  07      		RLC
 721: 3791+4	A820  07      		RLC	;(A)=(B)*8
 722: 3795+4	A821  80      		ADD	B	;.......*9
 723: 3799+10	A822  DA09A6  		JC	SYNERR
 724: 3809+4	A825  80      		ADD	B	;.......*10
 725: 3813+10	A826  DA09A6  		JC	SYNERR
 726: 3823+4	A829  82      		ADD	D	;add in new digit now.
 727: 3827+10	A82A  DA09A6  	DECODE2	JC	SYNERR
 728: 3837+5	A82D  47      		MOV	B,A	;and save result.
 729: 3842+5	A82E  0D      		DCR	C	;only look at 11 digits.
 730: 3847+10	A82F  C208A8  		JNZ	DECODE1
 731: 3857+10	A832  C9      		RET
 732: 3867+7	A833  7E      	DECODE3	MOV	A,M	;spaces must follow (why?).
 733: 3874+7	A834  FE20    		CPI	' '
 734: 3881+10	A836  C209A6  		JNZ	SYNERR
 735: 3891+5	A839  23      		INX	H
 736: 3896+5	A83A  0D      	DECODE4	DCR	C
 737: 3901+10	A83B  C233A8  		JNZ	DECODE3
 738: 3911+5	A83E  78      		MOV	A,B	;set (A)=the numeric value entered.
 739: 3916+10	A83F  C9      		RET
 740:				;
 741:				;   Move 3 bytes from (HL) to (DE). Note that there is only
 742:				; one reference to this at (A2D5h).
 743:				;
 744: 3926+7	A840  0603    	MOVE3	MVI	B,3
 745:				;
 746:				;   Move (B) bytes from (HL) to (DE).
 747:				;
 748: 3933+7	A842  7E      	HL2DE	MOV	A,M
 749: 3940+7	A843  12      		STAX	D
 750: 3947+5	A844  23      		INX	H
 751: 3952+5	A845  13      		INX	D
 752: 3957+5	A846  05      		DCR	B
 753: 3962+10	A847  C242A8  		JNZ	HL2DE
 754: 3972+10	A84A  C9      		RET
 755:				;
 756:				;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
 757:				;
 758: 3982+10	A84B  218000  	EXTRACT	LXI	H,TBUFF
 759: 3992+4	A84E  81      		ADD	C
 760: 3996+17	A84F  CD59A6  		CALL	ADDHL
 761: 4013+7	A852  7E      		MOV	A,M
 762: 4020+10	A853  C9      		RET
 763:				;
 764:				;  Check drive specified. If it means a change, then the new
 765:				; drive will be selected. In any case, the drive byte of the
 766:				; fcb will be set to null (means use current drive).
 767:				;
 768: 4030+4	A854  AF      	DSELECT	XRA	A	;null out first byte of fcb.
 769: 4034+13	A855  32CDAB  		STA	FCB
 770: 4047+13	A858  3AF0AB  		LDA	CHGDRV	;a drive change indicated?
 771: 4060+4	A85B  B7      		ORA	A
 772: 4064+5+6	A85C  C8      		RZ
 773: 4069+5	A85D  3D      		DCR	A	;yes, is it the same as the current drive?
 774: 4074+10	A85E  21EFAB  		LXI	H,CDRIVE
 775: 4084+7	A861  BE      		CMP	M
 776: 4091+5+6	A862  C8      		RZ
 777: 4096+10	A863  C3BDA4  		JMP	DSKSEL	;no. Select it then.
 778:				;
 779:				;   Check the drive selection and reset it to the previous
 780:				; drive if it was changed for the preceeding command.
 781:				;
 782: 4106+13	A866  3AF0AB  	RESETDR	LDA	CHGDRV	;drive change indicated?
 783: 4119+4	A869  B7      		ORA	A
 784: 4123+5+6	A86A  C8      		RZ
 785: 4128+5	A86B  3D      		DCR	A	;yes, was it a different drive?
 786: 4133+10	A86C  21EFAB  		LXI	H,CDRIVE
 787: 4143+7	A86F  BE      		CMP	M
 788: 4150+5+6	A870  C8      		RZ
 789: 4155+13	A871  3AEFAB  		LDA	CDRIVE	;yes, re-select our old drive.
 790: 4168+10	A874  C3BDA4  		JMP	DSKSEL
 791:				;
 792:				;**************************************************************
 793:				;*
 794:				;*           D I R E C T O R Y   C O M M A N D
 795:				;*
 796:				;**************************************************************
 797:				;
 798: 4178+17	A877  CD5EA6  	DIRECT	CALL	CONVFST	;convert file name.
 799: 4195+17	A87A  CD54A8  		CALL	DSELECT	;select indicated drive.
 800: 4212+10	A87D  21CEAB  		LXI	H,FCB+1	;was any file indicated?
 801: 4222+7	A880  7E      		MOV	A,M
 802: 4229+7	A881  FE20    		CPI	' '
 803: 4236+10	A883  C28FA8  		JNZ	DIRECT2
 804: 4246+7	A886  060B    		MVI	B,11	;no. Fill field with '?' - same as *.*.
 805: 4253+10	A888  363F    	DIRECT1	MVI	M,'?'
 806: 4263+5	A88A  23      		INX	H
 807: 4268+5	A88B  05      		DCR	B
 808: 4273+10	A88C  C288A8  		JNZ	DIRECT1
 809: 4283+7	A88F  1E00    	DIRECT2	MVI	E,0	;set initial cursor position.
 810: 4290+11	A891  D5      		PUSH	D
 811: 4301+17	A892  CDE9A4  		CALL	SRCHFCB	;get first file name.
 812: 4318+11+6	A895  CCEAA7  		CZ	NONE	;none found at all?
 813: 4329+10	A898  CA1BA9  	DIRECT3	JZ	DIRECT9	;terminate if no more names.
 814: 4339+13	A89B  3AEEAB  		LDA	RTNCODE	;get file's position in segment (0-3).
 815: 4352+4	A89E  0F      		RRC
 816: 4356+4	A89F  0F      		RRC
 817: 4360+4	A8A0  0F      		RRC
 818: 4364+7	A8A1  E660    		ANI	60H	;(A)=position*32
 819: 4371+5	A8A3  4F      		MOV	C,A
 820: 4376+7	A8A4  3E0A    		MVI	A,10
 821: 4383+17	A8A6  CD4BA8  		CALL	EXTRACT	;extract the tenth entry in fcb.
 822: 4400+4	A8A9  17      		RAL		;check system file status bit.
 823: 4404+10	A8AA  DA0FA9  		JC	DIRECT8	;we don't list them.
 824: 4414+10	A8AD  D1      		POP	D
 825: 4424+5	A8AE  7B      		MOV	A,E	;bump name count.
 826: 4429+5	A8AF  1C      		INR	E
 827: 4434+11	A8B0  D5      		PUSH	D
 828: 4445+7	A8B1  E603    		ANI	03H	;at end of line?
 829: 4452+11	A8B3  F5      		PUSH	PSW
 830: 4463+10	A8B4  C2CCA8  		JNZ	DIRECT4
 831: 4473+17	A8B7  CD98A4  		CALL	CRLF	;yes, end this line and start another.
 832: 4490+11	A8BA  C5      		PUSH	B
 833: 4501+17	A8BB  CDD0A5  		CALL	GETDSK	;start line with ('A:').
 834: 4518+10	A8BE  C1      		POP	B
 835: 4528+7	A8BF  C641    		ADI	'A'
 836: 4535+17	A8C1  CD92A4  		CALL	PRINTB
 837: 4552+7	A8C4  3E3A    		MVI	A,':'
 838: 4559+17	A8C6  CD92A4  		CALL	PRINTB
 839: 4576+10	A8C9  C3D4A8  		JMP	DIRECT5
 840: 4586+17	A8CC  CDA2A4  	DIRECT4	CALL	SPACE	;add seperator between file names.
 841: 4603+7	A8CF  3E3A    		MVI	A,':'
 842: 4610+17	A8D1  CD92A4  		CALL	PRINTB
 843: 4627+17	A8D4  CDA2A4  	DIRECT5	CALL	SPACE
 844: 4644+7	A8D7  0601    		MVI	B,1	;'extract' each file name character at a time.
 845: 4651+5	A8D9  78      	DIRECT6	MOV	A,B
 846: 4656+17	A8DA  CD4BA8  		CALL	EXTRACT
 847: 4673+7	A8DD  E67F    		ANI	7FH	;strip bit 7 (status bit).
 848: 4680+7	A8DF  FE20    		CPI	' '	;are we at the end of the name?
 849: 4687+10	A8E1  C2F9A8  		JNZ	DRECT65
 850: 4697+10	A8E4  F1      		POP	PSW	;yes, don't print spaces at the end of a line.
 851: 4707+11	A8E5  F5      		PUSH	PSW
 852: 4718+7	A8E6  FE03    		CPI	3
 853: 4725+10	A8E8  C2F7A8  		JNZ	DRECT63
 854: 4735+7	A8EB  3E09    		MVI	A,9	;first check for no extension.
 855: 4742+17	A8ED  CD4BA8  		CALL	EXTRACT
 856: 4759+7	A8F0  E67F    		ANI	7FH
 857: 4766+7	A8F2  FE20    		CPI	' '
 858: 4773+10	A8F4  CA0EA9  		JZ	DIRECT7	;don't print spaces.
 859: 4783+7	A8F7  3E20    	DRECT63	MVI	A,' '	;else print them.
 860: 4790+17	A8F9  CD92A4  	DRECT65	CALL	PRINTB
 861: 4807+5	A8FC  04      		INR	B	;bump to next character psoition.
 862: 4812+5	A8FD  78      		MOV	A,B
 863: 4817+7	A8FE  FE0C    		CPI	12	;end of the name?
 864: 4824+10	A900  D20EA9  		JNC	DIRECT7
 865: 4834+7	A903  FE09    		CPI	9	;nope, starting extension?
 866: 4841+10	A905  C2D9A8  		JNZ	DIRECT6
 867: 4851+17	A908  CDA2A4  		CALL	SPACE	;yes, add seperating space.
 868: 4868+10	A90B  C3D9A8  		JMP	DIRECT6
 869: 4878+10	A90E  F1      	DIRECT7	POP	PSW	;get the next file name.
 870: 4888+17	A90F  CDC2A5  	DIRECT8	CALL	CHKCON	;first check console, quit on anything.
 871: 4905+10	A912  C21BA9  		JNZ	DIRECT9
 872: 4915+17	A915  CDE4A4  		CALL	SRCHNXT	;get next name.
 873: 4932+10	A918  C398A8  		JMP	DIRECT3	;and continue with our list.
 874: 4942+10	A91B  D1      	DIRECT9	POP	D	;restore the stack and return to command level.
 875: 4952+10	A91C  C386AB  		JMP	GETBACK
 876:				;
 877:				;**************************************************************
 878:				;*
 879:				;*                E R A S E   C O M M A N D
 880:				;*
 881:				;**************************************************************
 882:				;
 883: 4962+17	A91F  CD5EA6  	ERASE	CALL	CONVFST	;convert file name.
 884: 4979+7	A922  FE0B    		CPI	11	;was '*.*' entered?
 885: 4986+10	A924  C242A9  		JNZ	ERASE1
 886: 4996+10	A927  0152A9  		LXI	B,YESNO	;yes, ask for confirmation.
 887: 5006+17	A92A  CDA7A4  		CALL	PLINE
 888: 5023+17	A92D  CD39A5  		CALL	GETINP
 889: 5040+10	A930  2107A4  		LXI	H,INBUFF+1
 890: 5050+10	A933  35      		DCR	M	;must be exactly 'y'.
 891: 5060+10	A934  C282A7  		JNZ	CMMND1
 892: 5070+5	A937  23      		INX	H
 893: 5075+7	A938  7E      		MOV	A,M
 894: 5082+7	A939  FE59    		CPI	'Y'
 895: 5089+10	A93B  C282A7  		JNZ	CMMND1
 896: 5099+5	A93E  23      		INX	H
 897: 5104+16	A93F  2288A4  		SHLD	INPOINT	;save input line pointer.
 898: 5120+17	A942  CD54A8  	ERASE1	CALL	DSELECT	;select desired disk.
 899: 5137+10	A945  11CDAB  		LXI	D,FCB
 900: 5147+17	A948  CDEFA4  		CALL	DELETE	;delete the file.
 901: 5164+5	A94B  3C      		INR	A
 902: 5169+11+6	A94C  CCEAA7  		CZ	NONE	;not there?
 903: 5180+10	A94F  C386AB  		JMP	GETBACK	;return to command level now.
 904:     -	A952  416C6C20	YESNO	DB	"All (y/n)?",0
	              28792F6E
	              293F00
 905:				;
 906:				;**************************************************************
 907:				;*
 908:				;*            T Y P E   C O M M A N D
 909:				;*
 910:				;**************************************************************
 911:				;
 912: 5190+17	A95D  CD5EA6  	TYPE	CALL	CONVFST	;convert file name.
 913: 5207+10	A960  C209A6  		JNZ	SYNERR	;wild cards not allowed.
 914: 5217+17	A963  CD54A8  		CALL	DSELECT	;select indicated drive.
 915: 5234+17	A966  CDD0A4  		CALL	OPENFCB	;open the file.
 916: 5251+10	A969  CAA7A9  		JZ	TYPE5	;not there?
 917: 5261+17	A96C  CD98A4  		CALL	CRLF	;ok, start a new line on the screen.
 918: 5278+10	A96F  21F1AB  		LXI	H,NBYTES;initialize byte counter.
 919: 5288+10	A972  36FF    		MVI	M,0FFH	;set to read first sector.
 920: 5298+10	A974  21F1AB  	TYPE1	LXI	H,NBYTES
 921: 5308+7	A977  7E      	TYPE2	MOV	A,M	;have we written the entire sector?
 922: 5315+7	A978  FE80    		CPI	128
 923: 5322+10	A97A  DA87A9  		JC	TYPE3
 924: 5332+11	A97D  E5      		PUSH	H	;yes, read in the next one.
 925: 5343+17	A97E  CDFEA4  		CALL	READFCB
 926: 5360+10	A981  E1      		POP	H
 927: 5370+10	A982  C2A0A9  		JNZ	TYPE4	;end or error?
 928: 5380+4	A985  AF      		XRA	A	;ok, clear byte counter.
 929: 5384+7	A986  77      		MOV	M,A
 930: 5391+10	A987  34      	TYPE3	INR	M	;count this byte.
 931: 5401+10	A988  218000  		LXI	H,TBUFF	;and get the (A)th one from the buffer (TBUFF).
 932: 5411+17	A98B  CD59A6  		CALL	ADDHL
 933: 5428+7	A98E  7E      		MOV	A,M
 934: 5435+7	A98F  FE1A    		CPI	CNTRLZ	;end of file mark?
 935: 5442+10	A991  CA86AB  		JZ	GETBACK
 936: 5452+17	A994  CD8CA4  		CALL	PRINT	;no, print it.
 937: 5469+17	A997  CDC2A5  		CALL	CHKCON	;check console, quit if anything ready.
 938: 5486+10	A99A  C286AB  		JNZ	GETBACK
 939: 5496+10	A99D  C374A9  		JMP	TYPE1
 940:				;
 941:				;   Get here on an end of file or read error.
 942:				;
 943: 5506+5	A9A0  3D      	TYPE4	DCR	A	;read error?
 944: 5511+10	A9A1  CA86AB  		JZ	GETBACK
 945: 5521+17	A9A4  CDD9A7  		CALL	RDERROR	;yes, print message.
 946: 5538+17	A9A7  CD66A8  	TYPE5	CALL	RESETDR	;and reset proper drive
 947: 5555+10	A9AA  C309A6  		JMP	SYNERR	;now print file name with problem.
 948:				;
 949:				;**************************************************************
 950:				;*
 951:				;*            S A V E   C O M M A N D
 952:				;*
 953:				;**************************************************************
 954:				;
 955: 5565+17	A9AD  CDF8A7  	SAVE	CALL	DECODE	;get numeric number that follows SAVE.
 956: 5582+11	A9B0  F5      		PUSH	PSW	;save number of pages to write.
 957: 5593+17	A9B1  CD5EA6  		CALL	CONVFST	;convert file name.
 958: 5610+10	A9B4  C209A6  		JNZ	SYNERR	;wild cards not allowed.
 959: 5620+17	A9B7  CD54A8  		CALL	DSELECT	;select specified drive.
 960: 5637+10	A9BA  11CDAB  		LXI	D,FCB	;now delete this file.
 961: 5647+11	A9BD  D5      		PUSH	D
 962: 5658+17	A9BE  CDEFA4  		CALL	DELETE
 963: 5675+10	A9C1  D1      		POP	D
 964: 5685+17	A9C2  CD09A5  		CALL	CREATE	;and create it again.
 965: 5702+10	A9C5  CAFBA9  		JZ	SAVE3	;can't create?
 966: 5712+4	A9C8  AF      		XRA	A	;clear record number byte.
 967: 5716+13	A9C9  32EDAB  		STA	FCB+32
 968: 5729+10	A9CC  F1      		POP	PSW	;convert pages to sectors.
 969: 5739+5	A9CD  6F      		MOV	L,A
 970: 5744+7	A9CE  2600    		MVI	H,0
 971: 5751+10	A9D0  29      		DAD	H	;(HL)=number of sectors to write.
 972: 5761+10	A9D1  110001  		LXI	D,TBASE	;and we start from here.
 973: 5771+5	A9D4  7C      	SAVE1	MOV	A,H	;done yet?
 974: 5776+4	A9D5  B5      		ORA	L
 975: 5780+10	A9D6  CAF1A9  		JZ	SAVE2
 976: 5790+5	A9D9  2B      		DCX	H	;nope, count this and compute the start
 977: 5795+11	A9DA  E5      		PUSH	H	;of the next 128 byte sector.
 978: 5806+10	A9DB  218000  		LXI	H,128
 979: 5816+10	A9DE  19      		DAD	D
 980: 5826+11	A9DF  E5      		PUSH	H	;save it and set the transfer address.
 981: 5837+17	A9E0  CDD8A5  		CALL	DMASET
 982: 5854+10	A9E3  11CDAB  		LXI	D,FCB	;write out this sector now.
 983: 5864+17	A9E6  CD04A5  		CALL	WRTREC
 984: 5881+10	A9E9  D1      		POP	D	;reset (DE) to the start of the last sector.
 985: 5891+10	A9EA  E1      		POP	H	;restore sector count.
 986: 5901+10	A9EB  C2FBA9  		JNZ	SAVE3	;write error?
 987: 5911+10	A9EE  C3D4A9  		JMP	SAVE1
 988:				;
 989:				;   Get here after writing all of the file.
 990:				;
 991: 5921+10	A9F1  11CDAB  	SAVE2	LXI	D,FCB	;now close the file.
 992: 5931+17	A9F4  CDDAA4  		CALL	CLOSE
 993: 5948+5	A9F7  3C      		INR	A	;did it close ok?
 994: 5953+10	A9F8  C201AA  		JNZ	SAVE4
 995:				;
 996:				;   Print out error message (no space).
 997:				;
 998: 5963+10	A9FB  0107AA  	SAVE3	LXI	B,NOSPACE
 999: 5973+17	A9FE  CDA7A4  		CALL	PLINE
1000: 5990+17	AA01  CDD5A5  	SAVE4	CALL	STDDMA	;reset the standard dma address.
1001: 6007+10	AA04  C386AB  		JMP	GETBACK
1002:     -	AA07  4E6F2073	NOSPACE	DB	"No space",0
	              70616365
	              00
1003:				;
1004:				;**************************************************************
1005:				;*
1006:				;*           R E N A M E   C O M M A N D
1007:				;*
1008:				;**************************************************************
1009:				;
1010: 6017+17	AA10  CD5EA6  	RENAME	CALL	CONVFST	;convert first file name.
1011: 6034+10	AA13  C209A6  		JNZ	SYNERR	;wild cards not allowed.
1012: 6044+13	AA16  3AF0AB  		LDA	CHGDRV	;remember any change in drives specified.
1013: 6057+11	AA19  F5      		PUSH	PSW
1014: 6068+17	AA1A  CD54A8  		CALL	DSELECT	;and select this drive.
1015: 6085+17	AA1D  CDE9A4  		CALL	SRCHFCB	;is this file present?
1016: 6102+10	AA20  C279AA  		JNZ	RENAME6	;yes, print error message.
1017: 6112+10	AA23  21CDAB  		LXI	H,FCB	;yes, move this name into second slot.
1018: 6122+10	AA26  11DDAB  		LXI	D,FCB+16
1019: 6132+7	AA29  0610    		MVI	B,16
1020: 6139+17	AA2B  CD42A8  		CALL	HL2DE
1021: 6156+16	AA2E  2A88A4  		LHLD	INPOINT	;get input pointer.
1022: 6172+4	AA31  EB      		XCHG
1023: 6176+17	AA32  CD4FA6  		CALL	NONBLANK;get next non blank character.
1024: 6193+7	AA35  FE3D    		CPI	'='	;only allow an '=' or '_' seperator.
1025: 6200+10	AA37  CA3FAA  		JZ	RENAME1
1026: 6210+7	AA3A  FE5F    		CPI	'_'
1027: 6217+10	AA3C  C273AA  		JNZ	RENAME5
1028: 6227+4	AA3F  EB      	RENAME1	XCHG
1029: 6231+5	AA40  23      		INX	H	;ok, skip seperator.
1030: 6236+16	AA41  2288A4  		SHLD	INPOINT	;save input line pointer.
1031: 6252+17	AA44  CD5EA6  		CALL	CONVFST	;convert this second file name now.
1032: 6269+10	AA47  C273AA  		JNZ	RENAME5	;again, no wild cards.
1033: 6279+10	AA4A  F1      		POP	PSW	;if a drive was specified, then it
1034: 6289+5	AA4B  47      		MOV	B,A	;must be the same as before.
1035: 6294+10	AA4C  21F0AB  		LXI	H,CHGDRV
1036: 6304+7	AA4F  7E      		MOV	A,M
1037: 6311+4	AA50  B7      		ORA	A
1038: 6315+10	AA51  CA59AA  		JZ	RENAME2
1039: 6325+4	AA54  B8      		CMP	B
1040: 6329+7	AA55  70      		MOV	M,B
1041: 6336+10	AA56  C273AA  		JNZ	RENAME5	;they were different, error.
1042: 6346+7	AA59  70      	RENAME2	MOV	M,B;	reset as per the first file specification.
1043: 6353+4	AA5A  AF      		XRA	A
1044: 6357+13	AA5B  32CDAB  		STA	FCB	;clear the drive byte of the fcb.
1045: 6370+17	AA5E  CDE9A4  	RENAME3	CALL	SRCHFCB	;and go look for second file.
1046: 6387+10	AA61  CA6DAA  		JZ	RENAME4	;doesn't exist?
1047: 6397+10	AA64  11CDAB  		LXI	D,FCB
1048: 6407+17	AA67  CD0EA5  		CALL	RENAM	;ok, rename the file.
1049: 6424+10	AA6A  C386AB  		JMP	GETBACK
1050:				;
1051:				;   Process rename errors here.
1052:				;
1053: 6434+17	AA6D  CDEAA7  	RENAME4	CALL	NONE	;file not there.
1054: 6451+10	AA70  C386AB  		JMP	GETBACK
1055: 6461+17	AA73  CD66A8  	RENAME5	CALL	RESETDR	;bad command format.
1056: 6478+10	AA76  C309A6  		JMP	SYNERR
1057: 6488+10	AA79  0182AA  	RENAME6	LXI	B,EXISTS;destination file already exists.
1058: 6498+17	AA7C  CDA7A4  		CALL	PLINE
1059: 6515+10	AA7F  C386AB  		JMP	GETBACK
1060:     -	AA82  46696C65	EXISTS	DB	"File exists",0
	              20657869
	              73747300
1061:				;
1062:				;**************************************************************
1063:				;*
1064:				;*             U S E R   C O M M A N D
1065:				;*
1066:				;**************************************************************
1067:				;
1068: 6525+17	AA8E  CDF8A7  	USER	CALL	DECODE	;get numeric value following command.
1069: 6542+7	AA91  FE10    		CPI	16	;legal user number?
1070: 6549+10	AA93  D209A6  		JNC	SYNERR
1071: 6559+5	AA96  5F      		MOV	E,A	;yes but is there anything else?
1072: 6564+13	AA97  3ACEAB  		LDA	FCB+1
1073: 6577+7	AA9A  FE20    		CPI	' '
1074: 6584+10	AA9C  CA09A6  		JZ	SYNERR	;yes, that is not allowed.
1075: 6594+17	AA9F  CD15A5  		CALL	GETSETUC;ok, set user code.
1076: 6611+10	AAA2  C389AB  		JMP	GETBACK1
1077:				;
1078:				;**************************************************************
1079:				;*
1080:				;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1081:				;*
1082:				;**************************************************************
1083:				;
1084: 6621+17	AAA5  CDF5A5  	UNKNOWN	CALL	VERIFY	;check for valid system (why?).
1085: 6638+13	AAA8  3ACEAB  		LDA	FCB+1	;anything to execute?
1086: 6651+7	AAAB  FE20    		CPI	' '
1087: 6658+10	AAAD  C2C4AA  		JNZ	UNKWN1
1088: 6668+13	AAB0  3AF0AB  		LDA	CHGDRV	;nope, only a drive change?
1089: 6681+4	AAB3  B7      		ORA	A
1090: 6685+10	AAB4  CA89AB  		JZ	GETBACK1;neither???
1091: 6695+5	AAB7  3D      		DCR	A
1092: 6700+13	AAB8  32EFAB  		STA	CDRIVE	;ok, store new drive.
1093: 6713+17	AABB  CD29A5  		CALL	MOVECD	;set (TDRIVE) also.
1094: 6730+17	AABE  CDBDA4  		CALL	DSKSEL	;and select this drive.
1095: 6747+10	AAC1  C389AB  		JMP	GETBACK1;then return.
1096:				;
1097:				;   Here a file name was typed. Prepare to execute it.
1098:				;
1099: 6757+10	AAC4  11D6AB  	UNKWN1	LXI	D,FCB+9	;an extension specified?
1100: 6767+7	AAC7  1A      		LDAX	D
1101: 6774+7	AAC8  FE20    		CPI	' '
1102: 6781+10	AACA  C209A6  		JNZ	SYNERR	;yes, not allowed.
1103: 6791+11	AACD  D5      	UNKWN2	PUSH	D
1104: 6802+17	AACE  CD54A8  		CALL	DSELECT	;select specified drive.
1105: 6819+10	AAD1  D1      		POP	D
1106: 6829+10	AAD2  2183AB  		LXI	H,COMFILE	;set the extension to 'COM'.
1107: 6839+17	AAD5  CD40A8  		CALL	MOVE3
1108: 6856+17	AAD8  CDD0A4  		CALL	OPENFCB	;and open this file.
1109: 6873+10	AADB  CA6BAB  		JZ	UNKWN9	;not present?
1110:				;
1111:				;   Load in the program.
1112:				;
1113: 6883+10	AADE  210001  		LXI	H,TBASE	;store the program starting here.
1114: 6893+11	AAE1  E5      	UNKWN3	PUSH	H
1115: 6904+4	AAE2  EB      		XCHG
1116: 6908+17	AAE3  CDD8A5  		CALL	DMASET	;set transfer address.
1117: 6925+10	AAE6  11CDAB  		LXI	D,FCB	;and read the next record.
1118: 6935+17	AAE9  CDF9A4  		CALL	RDREC
1119: 6952+10	AAEC  C201AB  		JNZ	UNKWN4	;end of file or read error?
1120: 6962+10	AAEF  E1      		POP	H	;nope, bump pointer for next sector.
1121: 6972+10	AAF0  118000  		LXI	D,128
1122: 6982+10	AAF3  19      		DAD	D
1123: 6992+10	AAF4  1100A4  		LXI	D,CBASE	;enough room for the whole file?
1124: 7002+5	AAF7  7D      		MOV	A,L
1125: 7007+4	AAF8  93      		SUB	E
1126: 7011+5	AAF9  7C      		MOV	A,H
1127: 7016+4	AAFA  9A      		SBB	D
1128: 7020+10	AAFB  D271AB  		JNC	UNKWN0	;no, it can't fit.
1129: 7030+10	AAFE  C3E1AA  		JMP	UNKWN3
1130:				;
1131:				;   Get here after finished reading.
1132:				;
1133: 7040+10	AB01  E1      	UNKWN4	POP	H
1134: 7050+5	AB02  3D      		DCR	A	;normal end of file?
1135: 7055+10	AB03  C271AB  		JNZ	UNKWN0
1136: 7065+17	AB06  CD66A8  		CALL	RESETDR	;yes, reset previous drive.
1137: 7082+17	AB09  CD5EA6  		CALL	CONVFST	;convert the first file name that follows
1138: 7099+10	AB0C  21F0AB  		LXI	H,CHGDRV;command name.
1139: 7109+11	AB0F  E5      		PUSH	H
1140: 7120+7	AB10  7E      		MOV	A,M	;set drive code in default fcb.
1141: 7127+13	AB11  32CDAB  		STA	FCB
1142: 7140+7	AB14  3E10    		MVI	A,16	;put second name 16 bytes later.
1143: 7147+17	AB16  CD60A6  		CALL	CONVERT	;convert second file name.
1144: 7164+10	AB19  E1      		POP	H
1145: 7174+7	AB1A  7E      		MOV	A,M	;and set the drive for this second file.
1146: 7181+13	AB1B  32DDAB  		STA	FCB+16
1147: 7194+4	AB1E  AF      		XRA	A	;clear record byte in fcb.
1148: 7198+13	AB1F  32EDAB  		STA	FCB+32
1149: 7211+10	AB22  115C00  		LXI	D,TFCB	;move it into place at(005Ch).
1150: 7221+10	AB25  21CDAB  		LXI	H,FCB
1151: 7231+7	AB28  0621    		MVI	B,33
1152: 7238+17	AB2A  CD42A8  		CALL	HL2DE
1153: 7255+10	AB2D  2108A4  		LXI	H,INBUFF+2;now move the remainder of the input
1154: 7265+7	AB30  7E      	UNKWN5	MOV	A,M	;line down to (0080h). Look for a non blank.
1155: 7272+4	AB31  B7      		ORA	A	;or a null.
1156: 7276+10	AB32  CA3EAB  		JZ	UNKWN6
1157: 7286+7	AB35  FE20    		CPI	' '
1158: 7293+10	AB37  CA3EAB  		JZ	UNKWN6
1159: 7303+5	AB3A  23      		INX	H
1160: 7308+10	AB3B  C330AB  		JMP	UNKWN5
1161:				;
1162:				;   Do the line move now. It ends in a null byte.
1163:				;
1164: 7318+7	AB3E  0600    	UNKWN6	MVI	B,0	;keep a character count.
1165: 7325+10	AB40  118100  		LXI	D,TBUFF+1;data gets put here.
1166: 7335+7	AB43  7E      	UNKWN7	MOV	A,M	;move it now.
1167: 7342+7	AB44  12      		STAX	D
1168: 7349+4	AB45  B7      		ORA	A
1169: 7353+10	AB46  CA4FAB  		JZ	UNKWN8
1170: 7363+5	AB49  04      		INR	B
1171: 7368+5	AB4A  23      		INX	H
1172: 7373+5	AB4B  13      		INX	D
1173: 7378+10	AB4C  C343AB  		JMP	UNKWN7
1174: 7388+5	AB4F  78      	UNKWN8	MOV	A,B	;now store the character count.
1175: 7393+13	AB50  328000  		STA	TBUFF
1176: 7406+17	AB53  CD98A4  		CALL	CRLF	;clean up the screen.
1177: 7423+17	AB56  CDD5A5  		CALL	STDDMA	;set standard transfer address.
1178: 7440+17	AB59  CD1AA5  		CALL	SETCDRV	;reset current drive.
1179: 7457+17	AB5C  CD0001  		CALL	TBASE	;and execute the program.
1180:				;
1181:				;   Transiant programs return here (or reboot).
1182:				;
1183: 7474+10	AB5F  31ABAB  		LXI	SP,BATCH	;set stack first off.
1184: 7484+17	AB62  CD29A5  		CALL	MOVECD	;move current drive into place (TDRIVE).
1185: 7501+17	AB65  CDBDA4  		CALL	DSKSEL	;and reselect it.
1186: 7518+10	AB68  C382A7  		JMP	CMMND1	;back to comand mode.
1187:				;
1188:				;   Get here if some error occured.
1189:				;
1190: 7528+17	AB6B  CD66A8  	UNKWN9	CALL	RESETDR	;inproper format.
1191: 7545+10	AB6E  C309A6  		JMP	SYNERR
1192: 7555+10	AB71  017AAB  	UNKWN0	LXI	B,BADLOAD;read error or won't fit.
1193: 7565+17	AB74  CDA7A4  		CALL	PLINE
1194: 7582+10	AB77  C386AB  		JMP	GETBACK
1195:     -	AB7A  42616420	BADLOAD	DB	"Bad load",0
	              6C6F6164
	              00
1196:     -	AB83  434F4D  	COMFILE	DB	"COM"	;command file extension.
1197:				;
1198:				;   Get here to return to command level. We will reset the
1199:				; previous active drive and then either return to command
1200:				; level directly or print error message and then return.
1201:				;
1202: 7592+17	AB86  CD66A8  	GETBACK	CALL	RESETDR	;reset previous drive.
1203: 7609+17	AB89  CD5EA6  	GETBACK1:CALL	CONVFST	;convert first name in (FCB).
1204: 7626+13	AB8C  3ACEAB  		LDA	FCB+1	;if this was just a drive change request,
1205: 7639+7	AB8F  D620    		SUI	' '	;make sure it was valid.
1206: 7646+10	AB91  21F0AB  		LXI	H,CHGDRV
1207: 7656+7	AB94  B6      		ORA	M
1208: 7663+10	AB95  C209A6  		JNZ	SYNERR
1209: 7673+10	AB98  C382A7  		JMP	CMMND1	;ok, return to command level.
1210:				;
1211:				;   ccp stack area.
1212:				;
1213:     -	AB9B  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
1214:     -	ABAB          	CCPSTACK:EQU	$	;end of ccp stack area.
1215:				;
1216:				;   Batch (or SUBMIT) processing information storage.
1217:				;
1218:     -	ABAB  00      	BATCH	DB	0	;batch mode flag (0=not active).
1219:     -	ABAC  00242424	BATCHFCB:DB	0,"$$$     SUB"
	              20202020
	              20535542
1220:     -	ABB8  00000000		 DB	0,0,0,0,0,0,0,0,0,0
	              00000000
	              0000
1221:     -	ABC2  00000000		 DB	0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              000000
1222:				;
1223:				;   File control block setup by the CCP.
1224:				;
1225:     -	ABCD  00202020	FCB	DB	0,"           ",0,0,0,0,0,"           ",0,0,0,0,0
	              20202020
	              20202020
	              00000000
	              00202020
	              20202020
	              20202020
	              00000000
	              00
1226:     -	ABEE  00      	RTNCODE	DB	0	;status returned from bdos call.
1227:     -	ABEF  00      	CDRIVE	DB	0	;currently active drive.
1228:     -	ABF0  00      	CHGDRV	DB	0	;change in drives flag (0=no change).
1229:     -	ABF1  0000    	NBYTES	DW	0	;byte counter used by TYPE.
1230:				;
1231:				;   Room for expansion?
1232:				;
1233:     -	ABF3  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00
1234:				;
1235:				;   Note that the following six bytes must match those at
1236:				; (PATTRN1) or cp/m will HALT. Why?
1237:				;
1238:     -	AC00  00160000	PATTRN2	DB	0,22,0,0,0,0;(* serial number bytes *).
	              0000
1239:				;
1240:				;**************************************************************
1241:				;*
1242:				;*                    B D O S   E N T R Y
1243:				;*
1244:				;**************************************************************
1245:				;
1246: 7683+10	AC06  C311AC  	FBASE	JMP	FBASE1
1247:				;
1248:				;   Bdos error table.
1249:				;
1250:     -	AC09  99AC    	BADSCTR	DW	ERROR1	;bad sector on read or write.
1251:     -	AC0B  A5AC    	BADSLCT	DW	ERROR2	;bad disk select.
1252:     -	AC0D  ABAC    	RODISK	DW	ERROR3	;disk is read only.
1253:     -	AC0F  B1AC    	ROFILE	DW	ERROR4	;file is read only.
1254:				;
1255:				;   Entry into bdos. (DE) or (E) are the parameters passed. The
1256:				; function number desired is in register (C).
1257:				;
1258: 7693+4	AC11  EB      	FBASE1	XCHG		;save the (DE) parameters.
1259: 7697+16	AC12  2243AF  		SHLD	PARAMS
1260: 7713+4	AC15  EB      		XCHG
1261: 7717+5	AC16  7B      		MOV	A,E	;and save register (E) in particular.
1262: 7722+13	AC17  32D6B9  		STA	EPARAM
1263: 7735+10	AC1A  210000  		LXI	H,0
1264: 7745+16	AC1D  2245AF  		SHLD	STATUS	;clear return status.
1265: 7761+10	AC20  39      		DAD	SP
1266: 7771+16	AC21  220FAF  		SHLD	USRSTACK;save users stack pointer.
1267: 7787+10	AC24  3141AF  		LXI	SP,STKAREA;and set our own.
1268: 7797+4	AC27  AF      		XRA	A	;clear auto select storage space.
1269: 7801+13	AC28  32E0B9  		STA	AUTOFLAG
1270: 7814+13	AC2B  32DEB9  		STA	AUTO
1271: 7827+10	AC2E  2174B9  		LXI	H,GOBACK;set return address.
1272: 7837+11	AC31  E5      		PUSH	H
1273: 7848+5	AC32  79      		MOV	A,C	;get function number.
1274: 7853+7	AC33  FE29    		CPI	NFUNCTS	;valid function number?
1275: 7860+5+6	AC35  D0      		RNC
1276: 7865+5	AC36  4B      		MOV	C,E	;keep single register function here.
1277: 7870+10	AC37  2147AC  		LXI	H,FUNCTNS;now look thru the function table.
1278: 7880+5	AC3A  5F      		MOV	E,A
1279: 7885+7	AC3B  1600    		MVI	D,0	;(DE)=function number.
1280: 7892+10	AC3D  19      		DAD	D
1281: 7902+10	AC3E  19      		DAD	D	;(HL)=(start of table)+2*(function number).
1282: 7912+7	AC3F  5E      		MOV	E,M
1283: 7919+5	AC40  23      		INX	H
1284: 7924+7	AC41  56      		MOV	D,M	;now (DE)=address for this function.
1285: 7931+16	AC42  2A43AF  		LHLD	PARAMS	;retrieve parameters.
1286: 7947+4	AC45  EB      		XCHG		;now (DE) has the original parameters.
1287: 7951+5	AC46  E9      		PCHL		;execute desired function.
1288:				;
1289:				;   BDOS function jump table.
1290:				;
1291:     -	0029          	NFUNCTS	EQU	41	;number of functions in followin table.
1292:				;
1293:     -	AC47  03BAC8AE	FUNCTNS	DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
	              90ADCEAE
	              12BA0FBA
	              D4AEEDAE
1294:     -	AC57  F3AEF8AE		DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
	              E1ADFEAE
	              7EB883B8
	              45B89CB8
1295:     -	AC67  A5B8ABB8		DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
	              C8B8D7B8
	              E0B8E6B8
	              ECB8
1296:     -	AC75  F5B8FEB8		DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
	              04B90AB9
	              11B92CB1
	              17B91DB9
1297:     -	AC85  26B92DB9		DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
	              41B947B9
	              4DB90EB8
	              53B904AF
1298:     -	AC95  04AF9BB9		DW	RTN,WTSPECL
1299:				;
1300:				;   Bdos error message section.
1301:				;
1302: 7956+10	AC99  21CAAC  	ERROR1	LXI	H,BADSEC	;bad sector message.
1303: 7966+17	AC9C  CDE5AC  		CALL	PRTERR	;print it and get a 1 char responce.
1304: 7983+7	AC9F  FE03    		CPI	CNTRLC	;re-boot request (control-c)?
1305: 7990+10	ACA1  CA0000  		JZ	0	;yes.
1306: 8000+10	ACA4  C9      		RET		;no, return to retry i/o function.
1307:				;
1308: 8010+10	ACA5  21D5AC  	ERROR2	LXI	H,BADSEL	;bad drive selected.
1309: 8020+10	ACA8  C3B4AC  		JMP	ERROR5
1310:				;
1311: 8030+10	ACAB  21E1AC  	ERROR3	LXI	H,DISKRO	;disk is read only.
1312: 8040+10	ACAE  C3B4AC  		JMP	ERROR5
1313:				;
1314: 8050+10	ACB1  21DCAC  	ERROR4	LXI	H,FILERO	;file is read only.
1315:				;
1316: 8060+17	ACB4  CDE5AC  	ERROR5	CALL	PRTERR
1317: 8077+10	ACB7  C30000  		JMP	0	;always reboot on these errors.
1318:				;
1319:     -	ACBA  42646F73	BDOSERR	DB	"Bdos Err On "
	              20457272
	              204F6E20
1320:     -	ACC6  203A2024	BDOSDRV	DB	" : $"
1321:     -	ACCA  42616420	BADSEC	DB	"Bad Sector$"
	              53656374
	              6F7224
1322:     -	ACD5  53656C65	BADSEL	DB	"Select$"
	              637424
1323:     -	ACDC  46696C65	FILERO	DB	"File "
	              20
1324:     -	ACE1  522F4F24	DISKRO	DB	"R/O$"
1325:				;
1326:				;   Print bdos error message.
1327:				;
1328: 8087+11	ACE5  E5      	PRTERR	PUSH	H	;save second message pointer.
1329: 8098+17	ACE6  CDC9AD  		CALL	OUTCRLF	;send (cr)(lf).
1330: 8115+13	ACE9  3A42AF  		LDA	ACTIVE	;get active drive.
1331: 8128+7	ACEC  C641    		ADI	'A'	;make ascii.
1332: 8135+13	ACEE  32C6AC  		STA	BDOSDRV	;and put in message.
1333: 8148+10	ACF1  01BAAC  		LXI	B,BDOSERR;and print it.
1334: 8158+17	ACF4  CDD3AD  		CALL	PRTMESG
1335: 8175+10	ACF7  C1      		POP	B	;print second message line now.
1336: 8185+17	ACF8  CDD3AD  		CALL	PRTMESG
1337:				;
1338:				;   Get an input character. We will check our 1 character
1339:				; buffer first. This may be set by the console status routine.
1340:				;
1341: 8202+10	ACFB  210EAF  	GETCHAR	LXI	H,CHARBUF;check character buffer.
1342: 8212+7	ACFE  7E      		MOV	A,M	;anything present already?
1343: 8219+10	ACFF  3600    		MVI	M,0	;...either case clear it.
1344: 8229+4	AD01  B7      		ORA	A
1345: 8233+5+6	AD02  C0      		RNZ		;yes, use it.
1346: 8238+10	AD03  C309BA  		JMP	CONIN	;nope, go get a character responce.
1347:				;
1348:				;   Input and echo a character.
1349:				;
1350: 8248+17	AD06  CDFBAC  	GETECHO	CALL	GETCHAR	;input a character.
1351: 8265+17	AD09  CD14AD  		CALL	CHKCHAR	;carriage control?
1352: 8282+5+6	AD0C  D8      		RC		;no, a regular control char so don't echo.
1353: 8287+11	AD0D  F5      		PUSH	PSW	;ok, save character now.
1354: 8298+5	AD0E  4F      		MOV	C,A
1355: 8303+17	AD0F  CD90AD  		CALL	OUTCON	;and echo it.
1356: 8320+10	AD12  F1      		POP	PSW	;get character and return.
1357: 8330+10	AD13  C9      		RET
1358:				;
1359:				;   Check character in (A). Set the zero flag on a carriage
1360:				; control character and the carry flag on any other control
1361:				; character.
1362:				;
1363: 8340+7	AD14  FE0D    	CHKCHAR	CPI	CR	;check for carriage return, line feed, backspace,
1364: 8347+5+6	AD16  C8      		RZ		;or a tab.
1365: 8352+7	AD17  FE0A    		CPI	LF
1366: 8359+5+6	AD19  C8      		RZ
1367: 8364+7	AD1A  FE09    		CPI	TAB
1368: 8371+5+6	AD1C  C8      		RZ
1369: 8376+7	AD1D  FE08    		CPI	BS
1370: 8383+5+6	AD1F  C8      		RZ
1371: 8388+7	AD20  FE20    		CPI	' '	;other control char? Set carry flag.
1372: 8395+10	AD22  C9      		RET
1373:				;
1374:				;   Check the console during output. Halt on a control-s, then
1375:				; reboot on a control-c. If anything else is ready, clear the
1376:				; zero flag and return (the calling routine may want to do
1377:				; something).
1378:				;
1379: 8405+13	AD23  3A0EAF  	CKCONSOL:LDA	CHARBUF	;check buffer.
1380: 8418+4	AD26  B7      		ORA	A	;if anything, just return without checking.
1381: 8422+10	AD27  C245AD  		JNZ	CKCON2
1382: 8432+17	AD2A  CD06BA  		CALL	CONST	;nothing in buffer. Check console.
1383: 8449+7	AD2D  E601    		ANI	01H	;look at bit 0.
1384: 8456+5+6	AD2F  C8      		RZ		;return if nothing.
1385: 8461+17	AD30  CD09BA  		CALL	CONIN	;ok, get it.
1386: 8478+7	AD33  FE13    		CPI	CNTRLS	;if not control-s, return with zero cleared.
1387: 8485+10	AD35  C242AD  		JNZ	CKCON1
1388: 8495+17	AD38  CD09BA  		CALL	CONIN	;halt processing until another char
1389: 8512+7	AD3B  FE03    		CPI	CNTRLC	;is typed. Control-c?
1390: 8519+10	AD3D  CA0000  		JZ	0	;yes, reboot now.
1391: 8529+4	AD40  AF      		XRA	A	;no, just pretend nothing was ever ready.
1392: 8533+10	AD41  C9      		RET
1393: 8543+13	AD42  320EAF  	CKCON1	STA	CHARBUF	;save character in buffer for later processing.
1394: 8556+7	AD45  3E01    	CKCON2	MVI	A,1	;set (A) to non zero to mean something is ready.
1395: 8563+10	AD47  C9      		RET
1396:				;
1397:				;   Output (C) to the screen. If the printer flip-flop flag
1398:				; is set, we will send character to printer also. The console
1399:				; will be checked in the process.
1400:				;
1401: 8573+13	AD48  3A0AAF  	OUTCHAR	LDA	OUTFLAG	;check output flag.
1402: 8586+4	AD4B  B7      		ORA	A	;anything and we won't generate output.
1403: 8590+10	AD4C  C262AD  		JNZ	OUTCHR1
1404: 8600+11	AD4F  C5      		PUSH	B
1405: 8611+17	AD50  CD23AD  		CALL	CKCONSOL;check console (we don't care whats there).
1406: 8628+10	AD53  C1      		POP	B
1407: 8638+11	AD54  C5      		PUSH	B
1408: 8649+17	AD55  CD0CBA  		CALL	CONOUT	;output (C) to the screen.
1409: 8666+10	AD58  C1      		POP	B
1410: 8676+11	AD59  C5      		PUSH	B
1411: 8687+13	AD5A  3A0DAF  		LDA	PRTFLAG	;check printer flip-flop flag.
1412: 8700+4	AD5D  B7      		ORA	A
1413: 8704+11+6	AD5E  C40FBA  		CNZ	LIST	;print it also if non-zero.
1414: 8715+10	AD61  C1      		POP	B
1415: 8725+5	AD62  79      	OUTCHR1	MOV	A,C	;update cursors position.
1416: 8730+10	AD63  210CAF  		LXI	H,CURPOS
1417: 8740+7	AD66  FE7F    		CPI	DEL	;rubouts don't do anything here.
1418: 8747+5+6	AD68  C8      		RZ
1419: 8752+10	AD69  34      		INR	M	;bump line pointer.
1420: 8762+7	AD6A  FE20    		CPI	' '	;and return if a normal character.
1421: 8769+5+6	AD6C  D0      		RNC
1422: 8774+10	AD6D  35      		DCR	M	;restore and check for the start of the line.
1423: 8784+7	AD6E  7E      		MOV	A,M
1424: 8791+4	AD6F  B7      		ORA	A
1425: 8795+5+6	AD70  C8      		RZ		;ingnore control characters at the start of the line.
1426: 8800+5	AD71  79      		MOV	A,C
1427: 8805+7	AD72  FE08    		CPI	BS	;is it a backspace?
1428: 8812+10	AD74  C279AD  		JNZ	OUTCHR2
1429: 8822+10	AD77  35      		DCR	M	;yes, backup pointer.
1430: 8832+10	AD78  C9      		RET
1431: 8842+7	AD79  FE0A    	OUTCHR2	CPI	LF	;is it a line feed?
1432: 8849+5+6	AD7B  C0      		RNZ		;ignore anything else.
1433: 8854+10	AD7C  3600    		MVI	M,0	;reset pointer to start of line.
1434: 8864+10	AD7E  C9      		RET
1435:				;
1436:				;   Output (A) to the screen. If it is a control character
1437:				; (other than carriage control), use ^x format.
1438:				;
1439: 8874+5	AD7F  79      	SHOWIT	MOV	A,C
1440: 8879+17	AD80  CD14AD  		CALL	CHKCHAR	;check character.
1441: 8896+10	AD83  D290AD  		JNC	OUTCON	;not a control, use normal output.
1442: 8906+11	AD86  F5      		PUSH	PSW
1443: 8917+7	AD87  0E5E    		MVI	C,'^'	;for a control character, preceed it with '^'.
1444: 8924+17	AD89  CD48AD  		CALL	OUTCHAR
1445: 8941+10	AD8C  F1      		POP	PSW
1446: 8951+7	AD8D  F640    		ORI	'@'	;and then use the letter equivelant.
1447: 8958+5	AD8F  4F      		MOV	C,A
1448:				;
1449:				;   Function to output (C) to the console device and expand tabs
1450:				; if necessary.
1451:				;
1452: 8963+5	AD90  79      	OUTCON	MOV	A,C
1453: 8968+7	AD91  FE09    		CPI	TAB	;is it a tab?
1454: 8975+10	AD93  C248AD  		JNZ	OUTCHAR	;use regular output.
1455: 8985+7	AD96  0E20    	OUTCON1	MVI	C,' '	;yes it is, use spaces instead.
1456: 8992+17	AD98  CD48AD  		CALL	OUTCHAR
1457: 9009+13	AD9B  3A0CAF  		LDA	CURPOS	;go until the cursor is at a multiple of 8
1458:				
1459: 9022+7	AD9E  E607    		ANI	07H	;position.
1460: 9029+10	ADA0  C296AD  		JNZ	OUTCON1
1461: 9039+10	ADA3  C9      		RET
1462:				;
1463:				;   Echo a backspace character. Erase the prevoius character
1464:				; on the screen.
1465:				;
1466: 9049+17	ADA4  CDACAD  	BACKUP	CALL	BACKUP1	;backup the screen 1 place.
1467: 9066+7	ADA7  0E20    		MVI	C,' '	;then blank that character.
1468: 9073+17	ADA9  CD0CBA  		CALL	CONOUT
1469: 9090+7	ADAC  0E08    	BACKUP1	MVI	C,BS	;then back space once more.
1470: 9097+10	ADAE  C30CBA  		JMP	CONOUT
1471:				;
1472:				;   Signal a deleted line. Print a '#' at the end and start
1473:				; over.
1474:				;
1475: 9107+7	ADB1  0E23    	NEWLINE	MVI	C,'#'
1476: 9114+17	ADB3  CD48AD  		CALL	OUTCHAR	;print this.
1477: 9131+17	ADB6  CDC9AD  		CALL	OUTCRLF	;start new line.
1478: 9148+13	ADB9  3A0CAF  	NEWLN1	LDA	CURPOS	;move the cursor to the starting position.
1479: 9161+10	ADBC  210BAF  		LXI	H,STARTING
1480: 9171+7	ADBF  BE      		CMP	M
1481: 9178+5+6	ADC0  D0      		RNC		;there yet?
1482: 9183+7	ADC1  0E20    		MVI	C,' '
1483: 9190+17	ADC3  CD48AD  		CALL	OUTCHAR	;nope, keep going.
1484: 9207+10	ADC6  C3B9AD  		JMP	NEWLN1
1485:				;
1486:				;   Output a (cr) (lf) to the console device (screen).
1487:				;
1488: 9217+7	ADC9  0E0D    	OUTCRLF	MVI	C,CR
1489: 9224+17	ADCB  CD48AD  		CALL	OUTCHAR
1490: 9241+7	ADCE  0E0A    		MVI	C,LF
1491: 9248+10	ADD0  C348AD  		JMP	OUTCHAR
1492:				;
1493:				;   Print message pointed to by (BC). It will end with a '$'.
1494:				;
1495: 9258+7	ADD3  0A      	PRTMESG	LDAX	B	;check for terminating character.
1496: 9265+7	ADD4  FE24    		CPI	'$'
1497: 9272+5+6	ADD6  C8      		RZ
1498: 9277+5	ADD7  03      		INX	B
1499: 9282+11	ADD8  C5      		PUSH	B	;otherwise, bump pointer and print it.
1500: 9293+5	ADD9  4F      		MOV	C,A
1501: 9298+17	ADDA  CD90AD  		CALL	OUTCON
1502: 9315+10	ADDD  C1      		POP	B
1503: 9325+10	ADDE  C3D3AD  		JMP	PRTMESG
1504:				;
1505:				;   Function to execute a buffered read.
1506:				;
1507: 9335+13	ADE1  3A0CAF  	RDBUFF	LDA	CURPOS	;use present location as starting one.
1508: 9348+13	ADE4  320BAF  		STA	STARTING
1509: 9361+16	ADE7  2A43AF  		LHLD	PARAMS	;get the maximum buffer space.
1510: 9377+7	ADEA  4E      		MOV	C,M
1511: 9384+5	ADEB  23      		INX	H	;point to first available space.
1512: 9389+11	ADEC  E5      		PUSH	H	;and save.
1513: 9400+7	ADED  0600    		MVI	B,0	;keep a character count.
1514: 9407+11	ADEF  C5      	RDBUF1	PUSH	B
1515: 9418+11	ADF0  E5      		PUSH	H
1516: 9429+17	ADF1  CDFBAC  	RDBUF2	CALL	GETCHAR	;get the next input character.
1517: 9446+7	ADF4  E67F    		ANI	7FH	;strip bit 7.
1518: 9453+10	ADF6  E1      		POP	H	;reset registers.
1519: 9463+10	ADF7  C1      		POP	B
1520: 9473+7	ADF8  FE0D    		CPI	CR	;en of the line?
1521: 9480+10	ADFA  CAC1AE  		JZ	RDBUF17
1522: 9490+7	ADFD  FE0A    		CPI	LF
1523: 9497+10	ADFF  CAC1AE  		JZ	RDBUF17
1524: 9507+7	AE02  FE08    		CPI	BS	;how about a backspace?
1525: 9514+10	AE04  C216AE  		JNZ	RDBUF3
1526: 9524+5	AE07  78      		MOV	A,B	;yes, but ignore at the beginning of the line.
1527: 9529+4	AE08  B7      		ORA	A
1528: 9533+10	AE09  CAEFAD  		JZ	RDBUF1
1529: 9543+5	AE0C  05      		DCR	B	;ok, update counter.
1530: 9548+13	AE0D  3A0CAF  		LDA	CURPOS	;if we backspace to the start of the line,
1531: 9561+13	AE10  320AAF  		STA	OUTFLAG	;treat as a cancel (control-x).
1532: 9574+10	AE13  C370AE  		JMP	RDBUF10
1533: 9584+7	AE16  FE7F    	RDBUF3	CPI	DEL	;user typed a rubout?
1534: 9591+10	AE18  C226AE  		JNZ	RDBUF4
1535: 9601+5	AE1B  78      		MOV	A,B	;ignore at the start of the line.
1536: 9606+4	AE1C  B7      		ORA	A
1537: 9610+10	AE1D  CAEFAD  		JZ	RDBUF1
1538: 9620+7	AE20  7E      		MOV	A,M	;ok, echo the prevoius character.
1539: 9627+5	AE21  05      		DCR	B	;and reset pointers (counters).
1540: 9632+5	AE22  2B      		DCX	H
1541: 9637+10	AE23  C3A9AE  		JMP	RDBUF15
1542: 9647+7	AE26  FE05    	RDBUF4	CPI	CNTRLE	;physical end of line?
1543: 9654+10	AE28  C237AE  		JNZ	RDBUF5
1544: 9664+11	AE2B  C5      		PUSH	B	;yes, do it.
1545: 9675+11	AE2C  E5      		PUSH	H
1546: 9686+17	AE2D  CDC9AD  		CALL	OUTCRLF
1547: 9703+4	AE30  AF      		XRA	A	;and update starting position.
1548: 9707+13	AE31  320BAF  		STA	STARTING
1549: 9720+10	AE34  C3F1AD  		JMP	RDBUF2
1550: 9730+7	AE37  FE10    	RDBUF5	CPI	CNTRLP	;control-p?
1551: 9737+10	AE39  C248AE  		JNZ	RDBUF6
1552: 9747+11	AE3C  E5      		PUSH	H	;yes, flip the print flag filp-flop byte.
1553: 9758+10	AE3D  210DAF  		LXI	H,PRTFLAG
1554: 9768+7	AE40  3E01    		MVI	A,1	;PRTFLAG=1-PRTFLAG
1555: 9775+7	AE42  96      		SUB	M
1556: 9782+7	AE43  77      		MOV	M,A
1557: 9789+10	AE44  E1      		POP	H
1558: 9799+10	AE45  C3EFAD  		JMP	RDBUF1
1559: 9809+7	AE48  FE18    	RDBUF6	CPI	CNTRLX	;control-x (cancel)?
1560: 9816+10	AE4A  C25FAE  		JNZ	RDBUF8
1561: 9826+10	AE4D  E1      		POP	H
1562: 9836+13	AE4E  3A0BAF  	RDBUF7	LDA	STARTING;yes, backup the cursor to here.
1563: 9849+10	AE51  210CAF  		LXI	H,CURPOS
1564: 9859+7	AE54  BE      		CMP	M
1565: 9866+10	AE55  D2E1AD  		JNC	RDBUFF	;done yet?
1566: 9876+10	AE58  35      		DCR	M	;no, decrement pointer and output back up one space.
1567: 9886+17	AE59  CDA4AD  		CALL	BACKUP
1568: 9903+10	AE5C  C34EAE  		JMP	RDBUF7
1569: 9913+7	AE5F  FE15    	RDBUF8	CPI	CNTRLU	;cntrol-u (cancel line)?
1570: 9920+10	AE61  C26BAE  		JNZ	RDBUF9
1571: 9930+17	AE64  CDB1AD  		CALL	NEWLINE	;start a new line.
1572: 9947+10	AE67  E1      		POP	H
1573: 9957+10	AE68  C3E1AD  		JMP	RDBUFF
1574: 9967+7	AE6B  FE12    	RDBUF9	CPI	CNTRLR	;control-r?
1575: 9974+10	AE6D  C2A6AE  		JNZ	RDBUF14
1576: 9984+11	AE70  C5      	RDBUF10	PUSH	B	;yes, start a new line and retype the old one.
1577: 9995+17	AE71  CDB1AD  		CALL	NEWLINE
1578:10012+10	AE74  C1      		POP	B
1579:10022+10	AE75  E1      		POP	H
1580:10032+11	AE76  E5      		PUSH	H
1581:10043+11	AE77  C5      		PUSH	B
1582:10054+5	AE78  78      	RDBUF11	MOV	A,B	;done whole line yet?
1583:10059+4	AE79  B7      		ORA	A
1584:10063+10	AE7A  CA8AAE  		JZ	RDBUF12
1585:10073+5	AE7D  23      		INX	H	;nope, get next character.
1586:10078+7	AE7E  4E      		MOV	C,M
1587:10085+5	AE7F  05      		DCR	B	;count it.
1588:10090+11	AE80  C5      		PUSH	B
1589:10101+11	AE81  E5      		PUSH	H
1590:10112+17	AE82  CD7FAD  		CALL	SHOWIT	;and display it.
1591:10129+10	AE85  E1      		POP	H
1592:10139+10	AE86  C1      		POP	B
1593:10149+10	AE87  C378AE  		JMP	RDBUF11
1594:10159+11	AE8A  E5      	RDBUF12	PUSH	H	;done with line. If we were displaying
1595:10170+13	AE8B  3A0AAF  		LDA	OUTFLAG	;then update cursor position.
1596:10183+4	AE8E  B7      		ORA	A
1597:10187+10	AE8F  CAF1AD  		JZ	RDBUF2
1598:10197+10	AE92  210CAF  		LXI	H,CURPOS;because this line is shorter, we must
1599:10207+7	AE95  96      		SUB	M	;back up the cursor (not the screen however)
1600:10214+13	AE96  320AAF  		STA	OUTFLAG	;some number of positions.
1601:10227+17	AE99  CDA4AD  	RDBUF13	CALL	BACKUP	;note that as long as (OUTFLAG) is non
1602:10244+10	AE9C  210AAF  		LXI	H,OUTFLAG;zero, the screen will not be changed.
1603:10254+10	AE9F  35      		DCR	M
1604:10264+10	AEA0  C299AE  		JNZ	RDBUF13
1605:10274+10	AEA3  C3F1AD  		JMP	RDBUF2	;now just get the next character.
1606:				;
1607:				;   Just a normal character, put this in our buffer and echo.
1608:				;
1609:10284+5	AEA6  23      	RDBUF14	INX	H
1610:10289+7	AEA7  77      		MOV	M,A	;store character.
1611:10296+5	AEA8  04      		INR	B	;and count it.
1612:10301+11	AEA9  C5      	RDBUF15	PUSH	B
1613:10312+11	AEAA  E5      		PUSH	H
1614:10323+5	AEAB  4F      		MOV	C,A	;echo it now.
1615:10328+17	AEAC  CD7FAD  		CALL	SHOWIT
1616:10345+10	AEAF  E1      		POP	H
1617:10355+10	AEB0  C1      		POP	B
1618:10365+7	AEB1  7E      		MOV	A,M	;was it an abort request?
1619:10372+7	AEB2  FE03    		CPI	CNTRLC	;control-c abort?
1620:10379+5	AEB4  78      		MOV	A,B
1621:10384+10	AEB5  C2BDAE  		JNZ	RDBUF16
1622:10394+7	AEB8  FE01    		CPI	1	;only if at start of line.
1623:10401+10	AEBA  CA0000  		JZ	0
1624:10411+4	AEBD  B9      	RDBUF16	CMP	C	;nope, have we filled the buffer?
1625:10415+10	AEBE  DAEFAD  		JC	RDBUF1
1626:10425+10	AEC1  E1      	RDBUF17	POP	H	;yes end the line and return.
1627:10435+7	AEC2  70      		MOV	M,B
1628:10442+7	AEC3  0E0D    		MVI	C,CR
1629:10449+10	AEC5  C348AD  		JMP	OUTCHAR	;output (cr) and return.
1630:				;
1631:				;   Function to get a character from the console device.
1632:				;
1633:10459+17	AEC8  CD06AD  	GETCON	CALL	GETECHO	;get and echo.
1634:10476+10	AECB  C301AF  		JMP	SETSTAT	;save status and return.
1635:				;
1636:				;   Function to get a character from the tape reader device.
1637:				;
1638:10486+17	AECE  CD15BA  	GETRDR	CALL	READER	;get a character from reader, set status and return.
1639:10503+10	AED1  C301AF  		JMP	SETSTAT
1640:				;
1641:				;  Function to perform direct console i/o. If (C) contains (FF)
1642:				; then this is an input request. If (C) contains (FE) then
1643:				; this is a status request. Otherwise we are to output (C).
1644:				;
1645:10513+5	AED4  79      	DIRCIO	MOV	A,C	;test for (FF).
1646:10518+5	AED5  3C      		INR	A
1647:10523+10	AED6  CAE0AE  		JZ	DIRC1
1648:10533+5	AED9  3C      		INR	A	;test for (FE).
1649:10538+10	AEDA  CA06BA  		JZ	CONST
1650:10548+10	AEDD  C30CBA  		JMP	CONOUT	;just output (C).
1651:10558+17	AEE0  CD06BA  	DIRC1	CALL	CONST	;this is an input request.
1652:10575+4	AEE3  B7      		ORA	A
1653:10579+10	AEE4  CA91B9  		JZ	GOBACK1	;not ready? Just return (directly).
1654:10589+17	AEE7  CD09BA  		CALL	CONIN	;yes, get character.
1655:10606+10	AEEA  C301AF  		JMP	SETSTAT	;set status and return.
1656:				;
1657:				;   Function to return the i/o byte.
1658:				;
1659:10616+13	AEED  3A0300  	GETIOB	LDA	IOBYTE
1660:10629+10	AEF0  C301AF  		JMP	SETSTAT
1661:				;
1662:				;   Function to set the i/o byte.
1663:				;
1664:10639+10	AEF3  210300  	SETIOB	LXI	H,IOBYTE
1665:10649+7	AEF6  71      		MOV	M,C
1666:10656+10	AEF7  C9      		RET
1667:				;
1668:				;   Function to print the character string pointed to by (DE)
1669:				; on the console device. The string ends with a '$'.
1670:				;
1671:10666+4	AEF8  EB      	PRTSTR	XCHG
1672:10670+5	AEF9  4D      		MOV	C,L
1673:10675+5	AEFA  44      		MOV	B,H	;now (BC) points to it.
1674:10680+10	AEFB  C3D3AD  		JMP	PRTMESG
1675:				;
1676:				;   Function to interigate the console device.
1677:				;
1678:10690+17	AEFE  CD23AD  	GETCSTS	CALL	CKCONSOL
1679:				;
1680:				;   Get here to set the status and return to the cleanup
1681:				; section. Then back to the user.
1682:				;
1683:10707+13	AF01  3245AF  	SETSTAT	STA	STATUS
1684:10720+10	AF04  C9      	RTN	RET
1685:				;
1686:				;   Set the status to 1 (read or write error code).
1687:				;
1688:10730+7	AF05  3E01    	IOERR1	MVI	A,1
1689:10737+10	AF07  C301AF  		JMP	SETSTAT
1690:				;
1691:     -	AF0A  00      	OUTFLAG	DB	0	;output flag (non zero means no output).
1692:     -	AF0B  02      	STARTING:DB	2	;starting position for cursor.
1693:     -	AF0C  00      	CURPOS	DB	0	;cursor position (0=start of line).
1694:     -	AF0D  00      	PRTFLAG	DB	0	;printer flag (control-p toggle). List if non zero.
1695:     -	AF0E  00      	CHARBUF	DB	0	;single input character buffer.
1696:				;
1697:				;   Stack area for BDOS calls.
1698:				;
1699:     -	AF0F  0000    	USRSTACK:DW	0	;save users stack pointer here.
1700:				;
1701:     -	AF11  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1702:     -	AF1D  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1703:     -	AF29  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1704:     -	AF35  00000000		DB	0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
1705:     -	AF41          	STKAREA	EQU	$	;end of stack area.
1706:				;
1707:     -	AF41  00      	USERNO	DB	0	;current user number.
1708:     -	AF42  00      	ACTIVE	DB	0	;currently active drive.
1709:     -	AF43  0000    	PARAMS	DW	0	;save (DE) parameters here on entry.
1710:     -	AF45  0000    	STATUS	DW	0	;status returned from bdos function.
1711:				;
1712:				;   Select error occured, jump to error routine.
1713:				;
1714:10747+10	AF47  210BAC  	SLCTERR	LXI	H,BADSLCT
1715:				;
1716:				;   Jump to (HL) indirectly.
1717:				;
1718:10757+7	AF4A  5E      	JUMPHL	MOV	E,M
1719:10764+5	AF4B  23      		INX	H
1720:10769+7	AF4C  56      		MOV	D,M	;now (DE) contain the desired address.
1721:10776+4	AF4D  EB      		XCHG
1722:10780+5	AF4E  E9      		PCHL
1723:				;
1724:				;   Block move. (DE) to (HL), (C) bytes total.
1725:				;
1726:10785+5	AF4F  0C      	DE2HL	INR	C	;is count down to zero?
1727:10790+5	AF50  0D      	DE2HL1	DCR	C
1728:10795+5+6	AF51  C8      		RZ		;yes, we are done.
1729:10800+7	AF52  1A      		LDAX	D	;no, move one more byte.
1730:10807+7	AF53  77      		MOV	M,A
1731:10814+5	AF54  13      		INX	D
1732:10819+5	AF55  23      		INX	H
1733:10824+10	AF56  C350AF  		JMP	DE2HL1	;and repeat.
1734:				;
1735:				;   Select the desired drive.
1736:				;
1737:10834+13	AF59  3A42AF  	SELECT	LDA	ACTIVE	;get active disk.
1738:10847+5	AF5C  4F      		MOV	C,A
1739:10852+17	AF5D  CD1BBA  		CALL	SELDSK	;select it.
1740:10869+5	AF60  7C      		MOV	A,H	;valid drive?
1741:10874+4	AF61  B5      		ORA	L	;valid drive?
1742:10878+5+6	AF62  C8      		RZ		;return if not.
1743:				;
1744:				;   Here, the BIOS returned the address of the parameter block
1745:				; in (HL). We will extract the necessary pointers and save them.
1746:				;
1747:10883+7	AF63  5E      		MOV	E,M	;yes, get address of translation table into (DE).
1748:10890+5	AF64  23      		INX	H
1749:10895+7	AF65  56      		MOV	D,M
1750:10902+5	AF66  23      		INX	H
1751:10907+16	AF67  22B3B9  		SHLD	SCRATCH1	;save pointers to scratch areas.
1752:10923+5	AF6A  23      		INX	H
1753:10928+5	AF6B  23      		INX	H
1754:10933+16	AF6C  22B5B9  		SHLD	SCRATCH2	;ditto.
1755:10949+5	AF6F  23      		INX	H
1756:10954+5	AF70  23      		INX	H
1757:10959+16	AF71  22B7B9  		SHLD	SCRATCH3	;ditto.
1758:10975+5	AF74  23      		INX	H
1759:10980+5	AF75  23      		INX	H
1760:10985+4	AF76  EB      		XCHG		;now save the translation table address.
1761:10989+16	AF77  22D0B9  		SHLD	XLATE
1762:11005+10	AF7A  21B9B9  		LXI	H,DIRBUF	;put the next 8 bytes here.
1763:11015+7	AF7D  0E08    		MVI	C,8	;they consist of the directory buffer
1764:11022+17	AF7F  CD4FAF  		CALL	DE2HL	;pointer, parameter block pointer,
1765:11039+16	AF82  2ABBB9  		LHLD	DISKPB	;check and allocation vectors.
1766:11055+4	AF85  EB      		XCHG
1767:11059+10	AF86  21C1B9  		LXI	H,SECTORS	;move parameter block into our ram.
1768:11069+7	AF89  0E0F    		MVI	C,15	;it is 15 bytes long.
1769:11076+17	AF8B  CD4FAF  		CALL	DE2HL
1770:11093+16	AF8E  2AC6B9  		LHLD	DSKSIZE	;check disk size.
1771:11109+5	AF91  7C      		MOV	A,H	;more than 256 blocks on this?
1772:11114+10	AF92  21DDB9  		LXI	H,BIGDISK
1773:11124+10	AF95  36FF    		MVI	M,0FFH	;set to samll.
1774:11134+4	AF97  B7      		ORA	A
1775:11138+10	AF98  CA9DAF  		JZ	SELECT1
1776:11148+10	AF9B  3600    		MVI	M,0	;wrong, set to large.
1777:11158+7	AF9D  3EFF    	SELECT1	MVI	A,0FFH	;clear the zero flag.
1778:11165+4	AF9F  B7      		ORA	A
1779:11169+10	AFA0  C9      		RET
1780:				;
1781:				;   Routine to home the disk track head and clear pointers.
1782:				;
1783:11179+17	AFA1  CD18BA  	HOMEDRV	CALL	HOME	;home the head.
1784:11196+4	AFA4  AF      		XRA	A
1785:11200+16	AFA5  2AB5B9  		LHLD	SCRATCH2;set our track pointer also.
1786:11216+7	AFA8  77      		MOV	M,A
1787:11223+5	AFA9  23      		INX	H
1788:11228+7	AFAA  77      		MOV	M,A
1789:11235+16	AFAB  2AB7B9  		LHLD	SCRATCH3;and our sector pointer.
1790:11251+7	AFAE  77      		MOV	M,A
1791:11258+5	AFAF  23      		INX	H
1792:11263+7	AFB0  77      		MOV	M,A
1793:11270+10	AFB1  C9      		RET
1794:				;
1795:				;   Do the actual disk read and check the error return status.
1796:				;
1797:11280+17	AFB2  CD27BA  	DOREAD	CALL	READ
1798:11297+10	AFB5  C3BBAF  		JMP	IORET
1799:				;
1800:				;   Do the actual disk write and handle any bios error.
1801:				;
1802:11307+17	AFB8  CD2ABA  	DOWRITE	CALL	WRITE
1803:11324+4	AFBB  B7      	IORET	ORA	A
1804:11328+5+6	AFBC  C8      		RZ		;return unless an error occured.
1805:11333+10	AFBD  2109AC  		LXI	H,BADSCTR;bad read/write on this sector.
1806:11343+10	AFC0  C34AAF  		JMP	JUMPHL
1807:				;
1808:				;   Routine to select the track and sector that the desired
1809:				; block number falls in.
1810:				;
1811:11353+16	AFC3  2AEAB9  	TRKSEC	LHLD	FILEPOS	;get position of last accessed file
1812:11369+7	AFC6  0E02    		MVI	C,2	;in directory and compute sector #.
1813:11376+17	AFC8  CDEAB0  		CALL	SHIFTR	;sector #=file-position/4.
1814:11393+16	AFCB  22E5B9  		SHLD	BLKNMBR	;save this as the block number of interest.
1815:11409+16	AFCE  22ECB9  		SHLD	CKSUMTBL;what's it doing here too?
1816:				;
1817:				;   if the sector number has already been set (BLKNMBR), enter
1818:				; at this point.
1819:				;
1820:11425+10	AFD1  21E5B9  	TRKSEC1	LXI	H,BLKNMBR
1821:11435+7	AFD4  4E      		MOV	C,M	;move sector number into (BC).
1822:11442+5	AFD5  23      		INX	H
1823:11447+7	AFD6  46      		MOV	B,M
1824:11454+16	AFD7  2AB7B9  		LHLD	SCRATCH3;get current sector number and
1825:11470+7	AFDA  5E      		MOV	E,M	;move this into (DE).
1826:11477+5	AFDB  23      		INX	H
1827:11482+7	AFDC  56      		MOV	D,M
1828:11489+16	AFDD  2AB5B9  		LHLD	SCRATCH2;get current track number.
1829:11505+7	AFE0  7E      		MOV	A,M	;and this into (HL).
1830:11512+5	AFE1  23      		INX	H
1831:11517+7	AFE2  66      		MOV	H,M
1832:11524+5	AFE3  6F      		MOV	L,A
1833:11529+5	AFE4  79      	TRKSEC2	MOV	A,C	;is desired sector before current one?
1834:11534+4	AFE5  93      		SUB	E
1835:11538+5	AFE6  78      		MOV	A,B
1836:11543+4	AFE7  9A      		SBB	D
1837:11547+10	AFE8  D2FAAF  		JNC	TRKSEC3
1838:11557+11	AFEB  E5      		PUSH	H	;yes, decrement sectors by one track.
1839:11568+16	AFEC  2AC1B9  		LHLD	SECTORS	;get sectors per track.
1840:11584+5	AFEF  7B      		MOV	A,E
1841:11589+4	AFF0  95      		SUB	L
1842:11593+5	AFF1  5F      		MOV	E,A
1843:11598+5	AFF2  7A      		MOV	A,D
1844:11603+4	AFF3  9C      		SBB	H
1845:11607+5	AFF4  57      		MOV	D,A	;now we have backed up one full track.
1846:11612+10	AFF5  E1      		POP	H
1847:11622+5	AFF6  2B      		DCX	H	;adjust track counter.
1848:11627+10	AFF7  C3E4AF  		JMP	TRKSEC2
1849:11637+11	AFFA  E5      	TRKSEC3	PUSH	H	;desired sector is after current one.
1850:11648+16	AFFB  2AC1B9  		LHLD	SECTORS	;get sectors per track.
1851:11664+10	AFFE  19      		DAD	D	;bump sector pointer to next track.
1852:11674+10	AFFF  DA0FB0  		JC	TRKSEC4
1853:11684+5	B002  79      		MOV	A,C	;is desired sector now before current one?
1854:11689+4	B003  95      		SUB	L
1855:11693+5	B004  78      		MOV	A,B
1856:11698+4	B005  9C      		SBB	H
1857:11702+10	B006  DA0FB0  		JC	TRKSEC4
1858:11712+4	B009  EB      		XCHG		;not yes, increment track counter
1859:11716+10	B00A  E1      		POP	H	;and continue until it is.
1860:11726+5	B00B  23      		INX	H
1861:11731+10	B00C  C3FAAF  		JMP	TRKSEC3
1862:				;
1863:				;   here we have determined the track number that contains the
1864:				; desired sector.
1865:				;
1866:11741+10	B00F  E1      	TRKSEC4	POP	H	;get track number (HL).
1867:11751+11	B010  C5      		PUSH	B
1868:11762+11	B011  D5      		PUSH	D
1869:11773+11	B012  E5      		PUSH	H
1870:11784+4	B013  EB      		XCHG
1871:11788+16	B014  2ACEB9  		LHLD	OFFSET	;adjust for first track offset.
1872:11804+10	B017  19      		DAD	D
1873:11814+5	B018  44      		MOV	B,H
1874:11819+5	B019  4D      		MOV	C,L
1875:11824+17	B01A  CD1EBA  		CALL	SETTRK	;select this track.
1876:11841+10	B01D  D1      		POP	D	;reset current track pointer.
1877:11851+16	B01E  2AB5B9  		LHLD	SCRATCH2
1878:11867+7	B021  73      		MOV	M,E
1879:11874+5	B022  23      		INX	H
1880:11879+7	B023  72      		MOV	M,D
1881:11886+10	B024  D1      		POP	D
1882:11896+16	B025  2AB7B9  		LHLD	SCRATCH3;reset the first sector on this track.
1883:11912+7	B028  73      		MOV	M,E
1884:11919+5	B029  23      		INX	H
1885:11924+7	B02A  72      		MOV	M,D
1886:11931+10	B02B  C1      		POP	B
1887:11941+5	B02C  79      		MOV	A,C	;now subtract the desired one.
1888:11946+4	B02D  93      		SUB	E	;to make it relative (1-# sectors/track).
1889:11950+5	B02E  4F      		MOV	C,A
1890:11955+5	B02F  78      		MOV	A,B
1891:11960+4	B030  9A      		SBB	D
1892:11964+5	B031  47      		MOV	B,A
1893:11969+16	B032  2AD0B9  		LHLD	XLATE	;translate this sector according to this table.
1894:11985+4	B035  EB      		XCHG
1895:11989+17	B036  CD30BA  		CALL	SECTRN	;let the bios translate it.
1896:12006+5	B039  4D      		MOV	C,L
1897:12011+5	B03A  44      		MOV	B,H
1898:12016+10	B03B  C321BA  		JMP	SETSEC	;and select it.
1899:				;
1900:				;   Compute block number from record number (SAVNREC) and
1901:				; extent number (SAVEXT).
1902:				;
1903:12026+10	B03E  21C3B9  	GETBLOCK:LXI	H,BLKSHFT;get logical to physical conversion.
1904:12036+7	B041  4E      		MOV	C,M	;note that this is base 2 log of ratio.
1905:12043+13	B042  3AE3B9  		LDA	SAVNREC	;get record number.
1906:12056+4	B045  B7      	GETBLK1	ORA	A	;compute (A)=(A)/2^BLKSHFT.
1907:12060+4	B046  1F      		RAR
1908:12064+5	B047  0D      		DCR	C
1909:12069+10	B048  C245B0  		JNZ	GETBLK1
1910:12079+5	B04B  47      		MOV	B,A	;save result in (B).
1911:12084+7	B04C  3E08    		MVI	A,8
1912:12091+7	B04E  96      		SUB	M
1913:12098+5	B04F  4F      		MOV	C,A	;compute (C)=8-BLKSHFT.
1914:12103+13	B050  3AE2B9  		LDA	SAVEXT
1915:12116+5	B053  0D      	GETBLK2	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
1916:12121+10	B054  CA5CB0  		JZ	GETBLK3
1917:12131+4	B057  B7      		ORA	A
1918:12135+4	B058  17      		RAL
1919:12139+10	B059  C353B0  		JMP	GETBLK2
1920:12149+4	B05C  80      	GETBLK3	ADD	B
1921:12153+10	B05D  C9      		RET
1922:				;
1923:				;   Routine to extract the (BC) block byte from the fcb pointed
1924:				; to by (PARAMS). If this is a big-disk, then these are 16 bit
1925:				; block numbers, else they are 8 bit numbers.
1926:				; Number is returned in (HL).
1927:				;
1928:12163+16	B05E  2A43AF  	EXTBLK	LHLD	PARAMS	;get fcb address.
1929:12179+10	B061  111000  		LXI	D,16	;block numbers start 16 bytes into fcb.
1930:12189+10	B064  19      		DAD	D
1931:12199+10	B065  09      		DAD	B
1932:12209+13	B066  3ADDB9  		LDA	BIGDISK	;are we using a big-disk?
1933:12222+4	B069  B7      		ORA	A
1934:12226+10	B06A  CA71B0  		JZ	EXTBLK1
1935:12236+7	B06D  6E      		MOV	L,M	;no, extract an 8 bit number from the fcb.
1936:12243+7	B06E  2600    		MVI	H,0
1937:12250+10	B070  C9      		RET
1938:12260+10	B071  09      	EXTBLK1	DAD	B	;yes, extract a 16 bit number.
1939:12270+7	B072  5E      		MOV	E,M
1940:12277+5	B073  23      		INX	H
1941:12282+7	B074  56      		MOV	D,M
1942:12289+4	B075  EB      		XCHG		;return in (HL).
1943:12293+10	B076  C9      		RET
1944:				;
1945:				;   Compute block number.
1946:				;
1947:12303+17	B077  CD3EB0  	COMBLK	CALL	GETBLOCK
1948:12320+5	B07A  4F      		MOV	C,A
1949:12325+7	B07B  0600    		MVI	B,0
1950:12332+17	B07D  CD5EB0  		CALL	EXTBLK
1951:12349+16	B080  22E5B9  		SHLD	BLKNMBR
1952:12365+10	B083  C9      		RET
1953:				;
1954:				;   Check for a zero block number (unused).
1955:				;
1956:12375+16	B084  2AE5B9  	CHKBLK	LHLD	BLKNMBR
1957:12391+5	B087  7D      		MOV	A,L	;is it zero?
1958:12396+4	B088  B4      		ORA	H
1959:12400+10	B089  C9      		RET
1960:				;
1961:				;   Adjust physical block (BLKNMBR) and convert to logical
1962:				; sector (LOGSECT). This is the starting sector of this block.
1963:				; The actual sector of interest is then added to this and the
1964:				; resulting sector number is stored back in (BLKNMBR). This
1965:				; will still have to be adjusted for the track number.
1966:				;
1967:12410+13	B08A  3AC3B9  	LOGICAL	LDA	BLKSHFT	;get log2(physical/logical sectors).
1968:12423+16	B08D  2AE5B9  		LHLD	BLKNMBR	;get physical sector desired.
1969:12439+10	B090  29      	LOGICL1	DAD	H	;compute logical sector number.
1970:12449+5	B091  3D      		DCR	A	;note logical sectors are 128 bytes long.
1971:12454+10	B092  C290B0  		JNZ	LOGICL1
1972:12464+16	B095  22E7B9  		SHLD	LOGSECT	;save logical sector.
1973:12480+13	B098  3AC4B9  		LDA	BLKMASK	;get block mask.
1974:12493+5	B09B  4F      		MOV	C,A
1975:12498+13	B09C  3AE3B9  		LDA	SAVNREC	;get next sector to access.
1976:12511+4	B09F  A1      		ANA	C	;extract the relative position within physical block.
1977:12515+4	B0A0  B5      		ORA	L	;and add it too logical sector.
1978:12519+5	B0A1  6F      		MOV	L,A
1979:12524+16	B0A2  22E5B9  		SHLD	BLKNMBR	;and store.
1980:12540+10	B0A5  C9      		RET
1981:				;
1982:				;   Set (HL) to point to extent byte in fcb.
1983:				;
1984:12550+16	B0A6  2A43AF  	SETEXT	LHLD	PARAMS
1985:12566+10	B0A9  110C00  		LXI	D,12	;it is the twelth byte.
1986:12576+10	B0AC  19      		DAD	D
1987:12586+10	B0AD  C9      		RET
1988:				;
1989:				;   Set (HL) to point to record count byte in fcb and (DE) to
1990:				; next record number byte.
1991:				;
1992:12596+16	B0AE  2A43AF  	SETHLDE	LHLD	PARAMS
1993:12612+10	B0B1  110F00  		LXI	D,15	;record count byte (#15).
1994:12622+10	B0B4  19      		DAD	D
1995:12632+4	B0B5  EB      		XCHG
1996:12636+10	B0B6  211100  		LXI	H,17	;next record number (#32).
1997:12646+10	B0B9  19      		DAD	D
1998:12656+10	B0BA  C9      		RET
1999:				;
2000:				;   Save current file data from fcb.
2001:				;
2002:12666+17	B0BB  CDAEB0  	STRDATA	CALL	SETHLDE
2003:12683+7	B0BE  7E      		MOV	A,M	;get and store record count byte.
2004:12690+13	B0BF  32E3B9  		STA	SAVNREC
2005:12703+4	B0C2  EB      		XCHG
2006:12707+7	B0C3  7E      		MOV	A,M	;get and store next record number byte.
2007:12714+13	B0C4  32E1B9  		STA	SAVNXT
2008:12727+17	B0C7  CDA6B0  		CALL	SETEXT	;point to extent byte.
2009:12744+13	B0CA  3AC5B9  		LDA	EXTMASK	;get extent mask.
2010:12757+7	B0CD  A6      		ANA	M
2011:12764+13	B0CE  32E2B9  		STA	SAVEXT	;and save extent here.
2012:12777+10	B0D1  C9      		RET
2013:				;
2014:				;   Set the next record to access. If (MODE) is set to 2, then
2015:				; the last record byte (SAVNREC) has the correct number to access.
2016:				; For sequential access, (MODE) will be equal to 1.
2017:				;
2018:12787+17	B0D2  CDAEB0  	SETNREC	CALL	SETHLDE
2019:12804+13	B0D5  3AD5B9  		LDA	MODE	;get sequential flag (=1).
2020:12817+7	B0D8  FE02    		CPI	2	;a 2 indicates that no adder is needed.
2021:12824+10	B0DA  C2DEB0  		JNZ	STNREC1
2022:12834+4	B0DD  AF      		XRA	A	;clear adder (random access?).
2023:12838+5	B0DE  4F      	STNREC1	MOV	C,A
2024:12843+13	B0DF  3AE3B9  		LDA	SAVNREC	;get last record number.
2025:12856+4	B0E2  81      		ADD	C	;increment record count.
2026:12860+7	B0E3  77      		MOV	M,A	;and set fcb's next record byte.
2027:12867+4	B0E4  EB      		XCHG
2028:12871+13	B0E5  3AE1B9  		LDA	SAVNXT	;get next record byte from storage.
2029:12884+7	B0E8  77      		MOV	M,A	;and put this into fcb as number of records used.
2030:12891+10	B0E9  C9      		RET
2031:				;
2032:				;   Shift (HL) right (C) bits.
2033:				;
2034:12901+5	B0EA  0C      	SHIFTR	INR	C
2035:12906+5	B0EB  0D      	SHIFTR1	DCR	C
2036:12911+5+6	B0EC  C8      		RZ
2037:12916+5	B0ED  7C      		MOV	A,H
2038:12921+4	B0EE  B7      		ORA	A
2039:12925+4	B0EF  1F      		RAR
2040:12929+5	B0F0  67      		MOV	H,A
2041:12934+5	B0F1  7D      		MOV	A,L
2042:12939+4	B0F2  1F      		RAR
2043:12943+5	B0F3  6F      		MOV	L,A
2044:12948+10	B0F4  C3EBB0  		JMP	SHIFTR1
2045:				;
2046:				;   Compute the check-sum for the directory buffer. Return
2047:				; integer sum in (A).
2048:				;
2049:12958+7	B0F7  0E80    	CHECKSUM:MVI	C,128	;length of buffer.
2050:12965+16	B0F9  2AB9B9  		LHLD	DIRBUF	;get its location.
2051:12981+4	B0FC  AF      		XRA	A	;clear summation byte.
2052:12985+7	B0FD  86      	CHKSUM1	ADD	M	;and compute sum ignoring carries.
2053:12992+5	B0FE  23      		INX	H
2054:12997+5	B0FF  0D      		DCR	C
2055:13002+10	B100  C2FDB0  		JNZ	CHKSUM1
2056:13012+10	B103  C9      		RET
2057:				;
2058:				;   Shift (HL) left (C) bits.
2059:				;
2060:13022+5	B104  0C      	SHIFTL	INR	C
2061:13027+5	B105  0D      	SHIFTL1	DCR	C
2062:13032+5+6	B106  C8      		RZ
2063:13037+10	B107  29      		DAD	H	;shift left 1 bit.
2064:13047+10	B108  C305B1  		JMP	SHIFTL1
2065:				;
2066:				;   Routine to set a bit in a 16 bit value contained in (BC).
2067:				; The bit set depends on the current drive selection.
2068:				;
2069:13057+11	B10B  C5      	SETBIT	PUSH	B	;save 16 bit word.
2070:13068+13	B10C  3A42AF  		LDA	ACTIVE	;get active drive.
2071:13081+5	B10F  4F      		MOV	C,A
2072:13086+10	B110  210100  		LXI	H,1
2073:13096+17	B113  CD04B1  		CALL	SHIFTL	;shift bit 0 into place.
2074:13113+10	B116  C1      		POP	B	;now 'or' this with the original word.
2075:13123+5	B117  79      		MOV	A,C
2076:13128+4	B118  B5      		ORA	L
2077:13132+5	B119  6F      		MOV	L,A	;low byte done, do high byte.
2078:13137+5	B11A  78      		MOV	A,B
2079:13142+4	B11B  B4      		ORA	H
2080:13146+5	B11C  67      		MOV	H,A
2081:13151+10	B11D  C9      		RET
2082:				;
2083:				;   Extract the write protect status bit for the current drive.
2084:				; The result is returned in (A), bit 0.
2085:				;
2086:13161+16	B11E  2AADB9  	GETWPRT	LHLD	WRTPRT	;get status bytes.
2087:13177+13	B121  3A42AF  		LDA	ACTIVE	;which drive is current?
2088:13190+5	B124  4F      		MOV	C,A
2089:13195+17	B125  CDEAB0  		CALL	SHIFTR	;shift status such that bit 0 is the
2090:13212+5	B128  7D      		MOV	A,L	;one of interest for this drive.
2091:13217+7	B129  E601    		ANI	01H	;and isolate it.
2092:13224+10	B12B  C9      		RET
2093:				;
2094:				;   Function to write protect the current disk.
2095:				;
2096:13234+10	B12C  21ADB9  	WRTPRTD	LXI	H,WRTPRT;point to status word.
2097:13244+7	B12F  4E      		MOV	C,M	;set (BC) equal to the status.
2098:13251+5	B130  23      		INX	H
2099:13256+7	B131  46      		MOV	B,M
2100:13263+17	B132  CD0BB1  		CALL	SETBIT	;and set this bit according to current drive.
2101:13280+16	B135  22ADB9  		SHLD	WRTPRT	;then save.
2102:13296+16	B138  2AC8B9  		LHLD	DIRSIZE	;now save directory size limit.
2103:13312+5	B13B  23      		INX	H	;remember the last one.
2104:13317+4	B13C  EB      		XCHG
2105:13321+16	B13D  2AB3B9  		LHLD	SCRATCH1;and store it here.
2106:13337+7	B140  73      		MOV	M,E	;put low byte.
2107:13344+5	B141  23      		INX	H
2108:13349+7	B142  72      		MOV	M,D	;then high byte.
2109:13356+10	B143  C9      		RET
2110:				;
2111:				;   Check for a read only file.
2112:				;
2113:13366+17	B144  CD5EB1  	CHKROFL	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2114:13383+10	B147  110900  	CKROF1	LXI	D,9	;look at bit 7 of the ninth byte.
2115:13393+10	B14A  19      		DAD	D
2116:13403+7	B14B  7E      		MOV	A,M
2117:13410+4	B14C  17      		RAL
2118:13414+5+6	B14D  D0      		RNC		;return if ok.
2119:13419+10	B14E  210FAC  		LXI	H,ROFILE;else, print error message and terminate.
2120:13429+10	B151  C34AAF  		JMP	JUMPHL
2121:				;
2122:				;   Check the write protect status of the active disk.
2123:				;
2124:13439+17	B154  CD1EB1  	CHKWPRT	CALL	GETWPRT
2125:13456+5+6	B157  C8      		RZ		;return if ok.
2126:13461+10	B158  210DAC  		LXI	H,RODISK;else print message and terminate.
2127:13471+10	B15B  C34AAF  		JMP	JUMPHL
2128:				;
2129:				;   Routine to set (HL) pointing to the proper entry in the
2130:				; directory buffer.
2131:				;
2132:13481+16	B15E  2AB9B9  	FCB2HL	LHLD	DIRBUF	;get address of buffer.
2133:13497+13	B161  3AE9B9  		LDA	FCBPOS	;relative position of file.
2134:				;
2135:				;   Routine to add (A) to (HL).
2136:				;
2137:13510+4	B164  85      	ADDA2HL	ADD	L
2138:13514+5	B165  6F      		MOV	L,A
2139:13519+5+6	B166  D0      		RNC
2140:13524+5	B167  24      		INR	H	;take care of any carry.
2141:13529+10	B168  C9      		RET
2142:				;
2143:				;   Routine to get the 's2' byte from the fcb supplied in
2144:				; the initial parameter specification.
2145:				;
2146:13539+16	B169  2A43AF  	GETS2	LHLD	PARAMS	;get address of fcb.
2147:13555+10	B16C  110E00  		LXI	D,14	;relative position of 's2'.
2148:13565+10	B16F  19      		DAD	D
2149:13575+7	B170  7E      		MOV	A,M	;extract this byte.
2150:13582+10	B171  C9      		RET
2151:				;
2152:				;   Clear the 's2' byte in the fcb.
2153:				;
2154:13592+17	B172  CD69B1  	CLEARS2	CALL	GETS2	;this sets (HL) pointing to it.
2155:13609+10	B175  3600    		MVI	M,0	;now clear it.
2156:13619+10	B177  C9      		RET
2157:				;
2158:				;   Set bit 7 in the 's2' byte of the fcb.
2159:				;
2160:13629+17	B178  CD69B1  	SETS2B7	CALL	GETS2	;get the byte.
2161:13646+7	B17B  F680    		ORI	80H	;and set bit 7.
2162:13653+7	B17D  77      		MOV	M,A	;then store.
2163:13660+10	B17E  C9      		RET
2164:				;
2165:				;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2166:				; the difference. This checks to see if there are more file
2167:				; names in the directory. We are at (FILEPOS) and there are
2168:				; (SCRATCH1) of them to check.
2169:				;
2170:13670+16	B17F  2AEAB9  	MOREFLS	LHLD	FILEPOS	;we are here.
2171:13686+4	B182  EB      		XCHG
2172:13690+16	B183  2AB3B9  		LHLD	SCRATCH1;and don't go past here.
2173:13706+5	B186  7B      		MOV	A,E	;compute difference but don't keep.
2174:13711+7	B187  96      		SUB	M
2175:13718+5	B188  23      		INX	H
2176:13723+5	B189  7A      		MOV	A,D
2177:13728+7	B18A  9E      		SBB	M	;set carry if no more names.
2178:13735+10	B18B  C9      		RET
2179:				;
2180:				;   Call this routine to prevent (SCRATCH1) from being greater
2181:				; than (FILEPOS).
2182:				;
2183:13745+17	B18C  CD7FB1  	CHKNMBR	CALL	MOREFLS	;SCRATCH1 too big?
2184:13762+5+6	B18F  D8      		RC
2185:13767+5	B190  13      		INX	D	;yes, reset it to (FILEPOS).
2186:13772+7	B191  72      		MOV	M,D
2187:13779+5	B192  2B      		DCX	H
2188:13784+7	B193  73      		MOV	M,E
2189:13791+10	B194  C9      		RET
2190:				;
2191:				;   Compute (HL)=(DE)-(HL)
2192:				;
2193:13801+5	B195  7B      	SUBHL	MOV	A,E	;compute difference.
2194:13806+4	B196  95      		SUB	L
2195:13810+5	B197  6F      		MOV	L,A	;store low byte.
2196:13815+5	B198  7A      		MOV	A,D
2197:13820+4	B199  9C      		SBB	H
2198:13824+5	B19A  67      		MOV	H,A	;and then high byte.
2199:13829+10	B19B  C9      		RET
2200:				;
2201:				;   Set the directory checksum byte.
2202:				;
2203:13839+7	B19C  0EFF    	SETDIR	MVI	C,0FFH
2204:				;
2205:				;   Routine to set or compare the directory checksum byte. If
2206:				; (C)=0ffh, then this will set the checksum byte. Else the byte
2207:				; will be checked. If the check fails (the disk has been changed),
2208:				; then this disk will be write protected.
2209:				;
2210:13846+16	B19E  2AECB9  	CHECKDIR:LHLD	CKSUMTBL
2211:13862+4	B1A1  EB      		XCHG
2212:13866+16	B1A2  2ACCB9  		LHLD	ALLOC1
2213:13882+17	B1A5  CD95B1  		CALL	SUBHL
2214:13899+5+6	B1A8  D0      		RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2215:13904+11	B1A9  C5      		PUSH	B
2216:13915+17	B1AA  CDF7B0  		CALL	CHECKSUM;else compute checksum.
2217:13932+16	B1AD  2ABDB9  		LHLD	CHKVECT	;get address of checksum table.
2218:13948+4	B1B0  EB      		XCHG
2219:13952+16	B1B1  2AECB9  		LHLD	CKSUMTBL
2220:13968+10	B1B4  19      		DAD	D	;set (HL) to point to byte for this drive.
2221:13978+10	B1B5  C1      		POP	B
2222:13988+5	B1B6  0C      		INR	C	;set or check ?
2223:13993+10	B1B7  CAC4B1  		JZ	CHKDIR1
2224:14003+7	B1BA  BE      		CMP	M	;check them.
2225:14010+5+6	B1BB  C8      		RZ		;return if they are the same.
2226:14015+17	B1BC  CD7FB1  		CALL	MOREFLS	;not the same, do we care?
2227:14032+5+6	B1BF  D0      		RNC
2228:14037+17	B1C0  CD2CB1  		CALL	WRTPRTD	;yes, mark this as write protected.
2229:14054+10	B1C3  C9      		RET
2230:14064+7	B1C4  77      	CHKDIR1	MOV	M,A	;just set the byte.
2231:14071+10	B1C5  C9      		RET
2232:				;
2233:				;   Do a write to the directory of the current disk.
2234:				;
2235:14081+17	B1C6  CD9CB1  	DIRWRITE:CALL	SETDIR	;set checksum byte.
2236:14098+17	B1C9  CDE0B1  		CALL	DIRDMA	;set directory dma address.
2237:14115+7	B1CC  0E01    		MVI	C,1	;tell the bios to actually write.
2238:14122+17	B1CE  CDB8AF  		CALL	DOWRITE	;then do the write.
2239:14139+10	B1D1  C3DAB1  		JMP	DEFDMA
2240:				;
2241:				;   Read from the directory.
2242:				;
2243:14149+17	B1D4  CDE0B1  	DIRREAD	CALL	DIRDMA	;set the directory dma address.
2244:14166+17	B1D7  CDB2AF  		CALL	DOREAD	;and read it.
2245:				;
2246:				;   Routine to set the dma address to the users choice.
2247:				;
2248:14183+10	B1DA  21B1B9  	DEFDMA	LXI	H,USERDMA;reset the default dma address and return.
2249:14193+10	B1DD  C3E3B1  		JMP	DIRDMA1
2250:				;
2251:				;   Routine to set the dma address for directory work.
2252:				;
2253:14203+10	B1E0  21B9B9  	DIRDMA	LXI	H,DIRBUF
2254:				;
2255:				;   Set the dma address. On entry, (HL) points to
2256:				; word containing the desired dma address.
2257:				;
2258:14213+7	B1E3  4E      	DIRDMA1	MOV	C,M
2259:14220+5	B1E4  23      		INX	H
2260:14225+7	B1E5  46      		MOV	B,M	;setup (BC) and go to the bios to set it.
2261:14232+10	B1E6  C324BA  		JMP	SETDMA
2262:				;
2263:				;   Move the directory buffer into user's dma space.
2264:				;
2265:14242+16	B1E9  2AB9B9  	MOVEDIR	LHLD	DIRBUF	;buffer is located here, and
2266:14258+4	B1EC  EB      		XCHG
2267:14262+16	B1ED  2AB1B9  		LHLD	USERDMA; put it here.
2268:14278+7	B1F0  0E80    		MVI	C,128	;this is its length.
2269:14285+10	B1F2  C34FAF  		JMP	DE2HL	;move it now and return.
2270:				;
2271:				;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2272:				;
2273:14295+10	B1F5  21EAB9  	CKFILPOS:LXI	H,FILEPOS
2274:14305+7	B1F8  7E      		MOV	A,M
2275:14312+5	B1F9  23      		INX	H
2276:14317+7	B1FA  BE      		CMP	M	;are both bytes the same?
2277:14324+5+6	B1FB  C0      		RNZ
2278:14329+5	B1FC  3C      		INR	A	;yes, but are they each 0ffh?
2279:14334+10	B1FD  C9      		RET
2280:				;
2281:				;   Set location (FILEPOS) to 0ffffh.
2282:				;
2283:14344+10	B1FE  21FFFF  	STFILPOS:LXI	H,0FFFFH
2284:14354+16	B201  22EAB9  		SHLD	FILEPOS
2285:14370+10	B204  C9      		RET
2286:				;
2287:				;   Move on to the next file position within the current
2288:				; directory buffer. If no more exist, set pointer to 0ffffh
2289:				; and the calling routine will check for this. Enter with (C)
2290:				; equal to 0ffh to cause the checksum byte to be set, else we
2291:				; will check this disk and set write protect if checksums are
2292:				; not the same (applies only if another directory sector must
2293:				; be read).
2294:				;
2295:14380+16	B205  2AC8B9  	NXENTRY	LHLD	DIRSIZE	;get directory entry size limit.
2296:14396+4	B208  EB      		XCHG
2297:14400+16	B209  2AEAB9  		LHLD	FILEPOS	;get current count.
2298:14416+5	B20C  23      		INX	H	;go on to the next one.
2299:14421+16	B20D  22EAB9  		SHLD	FILEPOS
2300:14437+17	B210  CD95B1  		CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
2301:14454+10	B213  D219B2  		JNC	NXENT1	;is there more room left?
2302:14464+10	B216  C3FEB1  		JMP	STFILPOS;no. Set this flag and return.
2303:14474+13	B219  3AEAB9  	NXENT1	LDA	FILEPOS	;get file position within directory.
2304:14487+7	B21C  E603    		ANI	03H	;only look within this sector (only 4 entries fit).
2305:14494+7	B21E  0605    		MVI	B,5	;convert to relative position (32 bytes each).
2306:14501+4	B220  87      	NXENT2	ADD	A	;note that this is not efficient code.
2307:14505+5	B221  05      		DCR	B	;5 'ADD A's would be better.
2308:14510+10	B222  C220B2  		JNZ	NXENT2
2309:14520+13	B225  32E9B9  		STA	FCBPOS	;save it as position of fcb.
2310:14533+4	B228  B7      		ORA	A
2311:14537+5+6	B229  C0      		RNZ		;return if we are within buffer.
2312:14542+11	B22A  C5      		PUSH	B
2313:14553+17	B22B  CDC3AF  		CALL	TRKSEC	;we need the next directory sector.
2314:14570+17	B22E  CDD4B1  		CALL	DIRREAD
2315:14587+10	B231  C1      		POP	B
2316:14597+10	B232  C39EB1  		JMP	CHECKDIR
2317:				;
2318:				;   Routine to to get a bit from the disk space allocation
2319:				; map. It is returned in (A), bit position 0. On entry to here,
2320:				; set (BC) to the block number on the disk to check.
2321:				; On return, (D) will contain the original bit position for
2322:				; this block number and (HL) will point to the address for it.
2323:				;
2324:14607+5	B235  79      	CKBITMAP:MOV	A,C	;determine bit number of interest.
2325:14612+7	B236  E607    		ANI	07H	;compute (D)=(E)=(C and 7)+1.
2326:14619+5	B238  3C      		INR	A
2327:14624+5	B239  5F      		MOV	E,A	;save particular bit number.
2328:14629+5	B23A  57      		MOV	D,A
2329:				;
2330:				;   compute (BC)=(BC)/8.
2331:				;
2332:14634+5	B23B  79      		MOV	A,C
2333:14639+4	B23C  0F      		RRC		;now shift right 3 bits.
2334:14643+4	B23D  0F      		RRC
2335:14647+4	B23E  0F      		RRC
2336:14651+7	B23F  E61F    		ANI	1FH	;and clear bits 7,6,5.
2337:14658+5	B241  4F      		MOV	C,A
2338:14663+5	B242  78      		MOV	A,B
2339:14668+4	B243  87      		ADD	A	;now shift (B) into bits 7,6,5.
2340:14672+4	B244  87      		ADD	A
2341:14676+4	B245  87      		ADD	A
2342:14680+4	B246  87      		ADD	A
2343:14684+4	B247  87      		ADD	A
2344:14688+4	B248  B1      		ORA	C	;and add in (C).
2345:14692+5	B249  4F      		MOV	C,A	;ok, (C) ha been completed.
2346:14697+5	B24A  78      		MOV	A,B	;is there a better way of doing this?
2347:14702+4	B24B  0F      		RRC
2348:14706+4	B24C  0F      		RRC
2349:14710+4	B24D  0F      		RRC
2350:14714+7	B24E  E61F    		ANI	1FH
2351:14721+5	B250  47      		MOV	B,A	;and now (B) is completed.
2352:				;
2353:				;   use this as an offset into the disk space allocation
2354:				; table.
2355:				;
2356:14726+16	B251  2ABFB9  		LHLD	ALOCVECT
2357:14742+10	B254  09      		DAD	B
2358:14752+7	B255  7E      		MOV	A,M	;now get correct byte.
2359:14759+4	B256  07      	CKBMAP1	RLC		;get correct bit into position 0.
2360:14763+5	B257  1D      		DCR	E
2361:14768+10	B258  C256B2  		JNZ	CKBMAP1
2362:14778+10	B25B  C9      		RET
2363:				;
2364:				;   Set or clear the bit map such that block number (BC) will be marked
2365:				; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2366:				; 1 then it will be set (don't use anyother values).
2367:				;
2368:14788+11	B25C  D5      	STBITMAP:PUSH	D
2369:14799+17	B25D  CD35B2  		CALL	CKBITMAP;get the byte of interest.
2370:14816+7	B260  E6FE    		ANI	0FEH	;clear the affected bit.
2371:14823+10	B262  C1      		POP	B
2372:14833+4	B263  B1      		ORA	C	;and now set it acording to (C).
2373:				;
2374:				;  entry to restore the original bit position and then store
2375:				; in table. (A) contains the value, (D) contains the bit
2376:				; position (1-8), and (HL) points to the address within the
2377:				; space allocation table for this byte.
2378:				;
2379:14837+4	B264  0F      	STBMAP1	RRC		;restore original bit position.
2380:14841+5	B265  15      		DCR	D
2381:14846+10	B266  C264B2  		JNZ	STBMAP1
2382:14856+7	B269  77      		MOV	M,A	;and stor byte in table.
2383:14863+10	B26A  C9      		RET
2384:				;
2385:				;   Set/clear space used bits in allocation map for this file.
2386:				; On entry, (C)=1 to set the map and (C)=0 to clear it.
2387:				;
2388:14873+17	B26B  CD5EB1  	SETFILE	CALL	FCB2HL	;get address of fcb
2389:14890+10	B26E  111000  		LXI	D,16
2390:14900+10	B271  19      		DAD	D	;get to block number bytes.
2391:14910+11	B272  C5      		PUSH	B
2392:14921+7	B273  0E11    		MVI	C,17	;check all 17 bytes (max) of table.
2393:14928+10	B275  D1      	SETFL1	POP	D
2394:14938+5	B276  0D      		DCR	C	;done all bytes yet?
2395:14943+5+6	B277  C8      		RZ
2396:14948+11	B278  D5      		PUSH	D
2397:14959+13	B279  3ADDB9  		LDA	BIGDISK	;check disk size for 16 bit block numbers.
2398:14972+4	B27C  B7      		ORA	A
2399:14976+10	B27D  CA88B2  		JZ	SETFL2
2400:14986+11	B280  C5      		PUSH	B	;only 8 bit numbers. set (BC) to this one.
2401:14997+11	B281  E5      		PUSH	H
2402:15008+7	B282  4E      		MOV	C,M	;get low byte from table, always
2403:15015+7	B283  0600    		MVI	B,0	;set high byte to zero.
2404:15022+10	B285  C38EB2  		JMP	SETFL3
2405:15032+5	B288  0D      	SETFL2	DCR	C	;for 16 bit block numbers, adjust counter.
2406:15037+11	B289  C5      		PUSH	B
2407:15048+7	B28A  4E      		MOV	C,M	;now get both the low and high bytes.
2408:15055+5	B28B  23      		INX	H
2409:15060+7	B28C  46      		MOV	B,M
2410:15067+11	B28D  E5      		PUSH	H
2411:15078+5	B28E  79      	SETFL3	MOV	A,C	;block used?
2412:15083+4	B28F  B0      		ORA	B
2413:15087+10	B290  CA9DB2  		JZ	SETFL4
2414:15097+16	B293  2AC6B9  		LHLD	DSKSIZE	;is this block number within the
2415:15113+5	B296  7D      		MOV	A,L	;space on the disk?
2416:15118+4	B297  91      		SUB	C
2417:15122+5	B298  7C      		MOV	A,H
2418:15127+4	B299  98      		SBB	B
2419:15131+11+6	B29A  D45CB2  		CNC	STBITMAP;yes, set the proper bit.
2420:15142+10	B29D  E1      	SETFL4	POP	H	;point to next block number in fcb.
2421:15152+5	B29E  23      		INX	H
2422:15157+10	B29F  C1      		POP	B
2423:15167+10	B2A0  C375B2  		JMP	SETFL1
2424:				;
2425:				;   Construct the space used allocation bit map for the active
2426:				; drive. If a file name starts with '$' and it is under the
2427:				; current user number, then (STATUS) is set to minus 1. Otherwise
2428:				; it is not set at all.
2429:				;
2430:15177+16	B2A3  2AC6B9  	BITMAP	LHLD	DSKSIZE	;compute size of allocation table.
2431:15193+7	B2A6  0E03    		MVI	C,3
2432:15200+17	B2A8  CDEAB0  		CALL	SHIFTR	;(HL)=(HL)/8.
2433:15217+5	B2AB  23      		INX	H	;at lease 1 byte.
2434:15222+5	B2AC  44      		MOV	B,H
2435:15227+5	B2AD  4D      		MOV	C,L	;set (BC) to the allocation table length.
2436:				;
2437:				;   Initialize the bitmap for this drive. Right now, the first
2438:				; two bytes are specified by the disk parameter block. However
2439:				; a patch could be entered here if it were necessary to setup
2440:				; this table in a special mannor. For example, the bios could
2441:				; determine locations of 'bad blocks' and set them as already
2442:				; 'used' in the map.
2443:				;
2444:15232+16	B2AE  2ABFB9  		LHLD	ALOCVECT;now zero out the table now.
2445:15248+10	B2B1  3600    	BITMAP1	MVI	M,0
2446:15258+5	B2B3  23      		INX	H
2447:15263+5	B2B4  0B      		DCX	B
2448:15268+5	B2B5  78      		MOV	A,B
2449:15273+4	B2B6  B1      		ORA	C
2450:15277+10	B2B7  C2B1B2  		JNZ	BITMAP1
2451:15287+16	B2BA  2ACAB9  		LHLD	ALLOC0	;get initial space used by directory.
2452:15303+4	B2BD  EB      		XCHG
2453:15307+16	B2BE  2ABFB9  		LHLD	ALOCVECT;and put this into map.
2454:15323+7	B2C1  73      		MOV	M,E
2455:15330+5	B2C2  23      		INX	H
2456:15335+7	B2C3  72      		MOV	M,D
2457:				;
2458:				;   End of initialization portion.
2459:				;
2460:15342+17	B2C4  CDA1AF  		CALL	HOMEDRV	;now home the drive.
2461:15359+16	B2C7  2AB3B9  		LHLD	SCRATCH1
2462:15375+10	B2CA  3603    		MVI	M,3	;force next directory request to read
2463:15385+5	B2CC  23      		INX	H	;in a sector.
2464:15390+10	B2CD  3600    		MVI	M,0
2465:15400+17	B2CF  CDFEB1  		CALL	STFILPOS;clear initial file position also.
2466:15417+7	B2D2  0EFF    	BITMAP2	MVI	C,0FFH	;read next file name in directory
2467:15424+17	B2D4  CD05B2  		CALL	NXENTRY	;and set checksum byte.
2468:15441+17	B2D7  CDF5B1  		CALL	CKFILPOS;is there another file?
2469:15458+5+6	B2DA  C8      		RZ
2470:15463+17	B2DB  CD5EB1  		CALL	FCB2HL	;yes, get its address.
2471:15480+7	B2DE  3EE5    		MVI	A,0E5H
2472:15487+7	B2E0  BE      		CMP	M	;empty file entry?
2473:15494+10	B2E1  CAD2B2  		JZ	BITMAP2
2474:15504+13	B2E4  3A41AF  		LDA	USERNO	;no, correct user number?
2475:15517+7	B2E7  BE      		CMP	M
2476:15524+10	B2E8  C2F6B2  		JNZ	BITMAP3
2477:15534+5	B2EB  23      		INX	H
2478:15539+7	B2EC  7E      		MOV	A,M	;yes, does name start with a '$'?
2479:15546+7	B2ED  D624    		SUI	'$'
2480:15553+10	B2EF  C2F6B2  		JNZ	BITMAP3
2481:15563+5	B2F2  3D      		DCR	A	;yes, set atatus to minus one.
2482:15568+13	B2F3  3245AF  		STA	STATUS
2483:15581+7	B2F6  0E01    	BITMAP3	MVI	C,1	;now set this file's space as used in bit map.
2484:15588+17	B2F8  CD6BB2  		CALL	SETFILE
2485:15605+17	B2FB  CD8CB1  		CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
2486:15622+10	B2FE  C3D2B2  		JMP	BITMAP2
2487:				;
2488:				;   Set the status (STATUS) and return.
2489:				;
2490:15632+13	B301  3AD4B9  	STSTATUS:LDA	FNDSTAT
2491:15645+10	B304  C301AF  		JMP	SETSTAT
2492:				;
2493:				;   Check extents in (A) and (C). Set the zero flag if they
2494:				; are the same. The number of 16k chunks of disk space that
2495:				; the directory extent covers is expressad is (EXTMASK+1).
2496:				; No registers are modified.
2497:				;
2498:15655+11	B307  C5      	SAMEXT	PUSH	B
2499:15666+11	B308  F5      		PUSH	PSW
2500:15677+13	B309  3AC5B9  		LDA	EXTMASK	;get extent mask and use it to
2501:15690+4	B30C  2F      		CMA		;to compare both extent numbers.
2502:15694+5	B30D  47      		MOV	B,A	;save resulting mask here.
2503:15699+5	B30E  79      		MOV	A,C	;mask first extent and save in (C).
2504:15704+4	B30F  A0      		ANA	B
2505:15708+5	B310  4F      		MOV	C,A
2506:15713+10	B311  F1      		POP	PSW	;now mask second extent and compare
2507:15723+4	B312  A0      		ANA	B	;with the first one.
2508:15727+4	B313  91      		SUB	C
2509:15731+7	B314  E61F    		ANI	1FH	;(* only check buts 0-4 *)
2510:15738+10	B316  C1      		POP	B	;the zero flag is set if they are the same.
2511:15748+10	B317  C9      		RET		;restore (BC) and return.
2512:				;
2513:				;   Search for the first occurence of a file name. On entry,
2514:				; register (C) should contain the number of bytes of the fcb
2515:				; that must match.
2516:				;
2517:15758+7	B318  3EFF    	FINDFST	MVI	A,0FFH
2518:15765+13	B31A  32D4B9  		STA	FNDSTAT
2519:15778+10	B31D  21D8B9  		LXI	H,COUNTER;save character count.
2520:15788+7	B320  71      		MOV	M,C
2521:15795+16	B321  2A43AF  		LHLD	PARAMS	;get filename to match.
2522:15811+16	B324  22D9B9  		SHLD	SAVEFCB	;and save.
2523:15827+17	B327  CDFEB1  		CALL	STFILPOS;clear initial file position (set to 0ffffh).
2524:15844+17	B32A  CDA1AF  		CALL	HOMEDRV	;home the drive.
2525:				;
2526:				;   Entry to locate the next occurence of a filename within the
2527:				; directory. The disk is not expected to have been changed. If
2528:				; it was, then it will be write protected.
2529:				;
2530:15861+7	B32D  0E00    	FINDNXT	MVI	C,0	;write protect the disk if changed.
2531:15868+17	B32F  CD05B2  		CALL	NXENTRY	;get next filename entry in directory.
2532:15885+17	B332  CDF5B1  		CALL	CKFILPOS;is file position = 0ffffh?
2533:15902+10	B335  CA94B3  		JZ	FNDNXT6	;yes, exit now then.
2534:15912+16	B338  2AD9B9  		LHLD	SAVEFCB	;set (DE) pointing to filename to match.
2535:15928+4	B33B  EB      		XCHG
2536:15932+7	B33C  1A      		LDAX	D
2537:15939+7	B33D  FEE5    		CPI	0E5H	;empty directory entry?
2538:15946+10	B33F  CA4AB3  		JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
2539:15956+11	B342  D5      		PUSH	D
2540:15967+17	B343  CD7FB1  		CALL	MOREFLS	;more files in directory?
2541:15984+10	B346  D1      		POP	D
2542:15994+10	B347  D294B3  		JNC	FNDNXT6	;no more. Exit now.
2543:16004+17	B34A  CD5EB1  	FNDNXT1	CALL	FCB2HL	;get address of this fcb in directory.
2544:16021+13	B34D  3AD8B9  		LDA	COUNTER	;get number of bytes (characters) to check.
2545:16034+5	B350  4F      		MOV	C,A
2546:16039+7	B351  0600    		MVI	B,0	;initialize byte position counter.
2547:16046+5	B353  79      	FNDNXT2	MOV	A,C	;are we done with the compare?
2548:16051+4	B354  B7      		ORA	A
2549:16055+10	B355  CA83B3  		JZ	FNDNXT5
2550:16065+7	B358  1A      		LDAX	D	;no, check next byte.
2551:16072+7	B359  FE3F    		CPI	'?'	;don't care about this character?
2552:16079+10	B35B  CA7CB3  		JZ	FNDNXT4
2553:16089+5	B35E  78      		MOV	A,B	;get bytes position in fcb.
2554:16094+7	B35F  FE0D    		CPI	13	;don't care about the thirteenth byte either.
2555:16101+10	B361  CA7CB3  		JZ	FNDNXT4
2556:16111+7	B364  FE0C    		CPI	12	;extent byte?
2557:16118+7	B366  1A      		LDAX	D
2558:16125+10	B367  CA73B3  		JZ	FNDNXT3
2559:16135+7	B36A  96      		SUB	M	;otherwise compare characters.
2560:16142+7	B36B  E67F    		ANI	7FH
2561:16149+10	B36D  C22DB3  		JNZ	FINDNXT	;not the same, check next entry.
2562:16159+10	B370  C37CB3  		JMP	FNDNXT4	;so far so good, keep checking.
2563:16169+11	B373  C5      	FNDNXT3	PUSH	B	;check the extent byte here.
2564:16180+7	B374  4E      		MOV	C,M
2565:16187+17	B375  CD07B3  		CALL	SAMEXT
2566:16204+10	B378  C1      		POP	B
2567:16214+10	B379  C22DB3  		JNZ	FINDNXT	;not the same, look some more.
2568:				;
2569:				;   So far the names compare. Bump pointers to the next byte
2570:				; and continue until all (C) characters have been checked.
2571:				;
2572:16224+5	B37C  13      	FNDNXT4	INX	D	;bump pointers.
2573:16229+5	B37D  23      		INX	H
2574:16234+5	B37E  04      		INR	B
2575:16239+5	B37F  0D      		DCR	C	;adjust character counter.
2576:16244+10	B380  C353B3  		JMP	FNDNXT2
2577:16254+13	B383  3AEAB9  	FNDNXT5	LDA	FILEPOS	;return the position of this entry.
2578:16267+7	B386  E603    		ANI	03H
2579:16274+13	B388  3245AF  		STA	STATUS
2580:16287+10	B38B  21D4B9  		LXI	H,FNDSTAT
2581:16297+7	B38E  7E      		MOV	A,M
2582:16304+4	B38F  17      		RAL
2583:16308+5+6	B390  D0      		RNC
2584:16313+4	B391  AF      		XRA	A
2585:16317+7	B392  77      		MOV	M,A
2586:16324+10	B393  C9      		RET
2587:				;
2588:				;   Filename was not found. Set appropriate status.
2589:				;
2590:16334+17	B394  CDFEB1  	FNDNXT6	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
2591:16351+7	B397  3EFF    		MVI	A,0FFH	;say not located.
2592:16358+10	B399  C301AF  		JMP	SETSTAT
2593:				;
2594:				;   Erase files from the directory. Only the first byte of the
2595:				; fcb will be affected. It is set to (E5).
2596:				;
2597:16368+17	B39C  CD54B1  	ERAFILE	CALL	CHKWPRT	;is disk write protected?
2598:16385+7	B39F  0E0C    		MVI	C,12	;only compare file names.
2599:16392+17	B3A1  CD18B3  		CALL	FINDFST	;get first file name.
2600:16409+17	B3A4  CDF5B1  	ERAFIL1	CALL	CKFILPOS;any found?
2601:16426+5+6	B3A7  C8      		RZ		;nope, we must be done.
2602:16431+17	B3A8  CD44B1  		CALL	CHKROFL	;is file read only?
2603:16448+17	B3AB  CD5EB1  		CALL	FCB2HL	;nope, get address of fcb and
2604:16465+10	B3AE  36E5    		MVI	M,0E5H	;set first byte to 'empty'.
2605:16475+7	B3B0  0E00    		MVI	C,0	;clear the space from the bit map.
2606:16482+17	B3B2  CD6BB2  		CALL	SETFILE
2607:16499+17	B3B5  CDC6B1  		CALL	DIRWRITE;now write the directory sector back out.
2608:16516+17	B3B8  CD2DB3  		CALL	FINDNXT	;find the next file name.
2609:16533+10	B3BB  C3A4B3  		JMP	ERAFIL1	;and repeat process.
2610:				;
2611:				;   Look through the space allocation map (bit map) for the
2612:				; next available block. Start searching at block number (BC-1).
2613:				; The search procedure is to look for an empty block that is
2614:				; before the starting block. If not empty, look at a later
2615:				; block number. In this way, we return the closest empty block
2616:				; on either side of the 'target' block number. This will speed
2617:				; access on random devices. For serial devices, this should be
2618:				; changed to look in the forward direction first and then start
2619:				; at the front and search some more.
2620:				;
2621:				;   On return, (DE)= block number that is empty and (HL) =0
2622:				; if no empry block was found.
2623:				;
2624:16543+5	B3BE  50      	FNDSPACE:MOV	D,B	;set (DE) as the block that is checked.
2625:16548+5	B3BF  59      		MOV	E,C
2626:				;
2627:				;   Look before target block. Registers (BC) are used as the lower
2628:				; pointer and (DE) as the upper pointer.
2629:				;
2630:16553+5	B3C0  79      	FNDSPA1	MOV	A,C	;is block 0 specified?
2631:16558+4	B3C1  B0      		ORA	B
2632:16562+10	B3C2  CAD1B3  		JZ	FNDSPA2
2633:16572+5	B3C5  0B      		DCX	B	;nope, check previous block.
2634:16577+11	B3C6  D5      		PUSH	D
2635:16588+11	B3C7  C5      		PUSH	B
2636:16599+17	B3C8  CD35B2  		CALL	CKBITMAP
2637:16616+4	B3CB  1F      		RAR		;is this block empty?
2638:16620+10	B3CC  D2ECB3  		JNC	FNDSPA3	;yes. use this.
2639:				;
2640:				;   Note that the above logic gets the first block that it finds
2641:				; that is empty. Thus a file could be written 'backward' making
2642:				; it very slow to access. This could be changed to look for the
2643:				; first empty block and then continue until the start of this
2644:				; empty space is located and then used that starting block.
2645:				; This should help speed up access to some files especially on
2646:				; a well used disk with lots of fairly small 'holes'.
2647:				;
2648:16630+10	B3CF  C1      		POP	B	;nope, check some more.
2649:16640+10	B3D0  D1      		POP	D
2650:				;
2651:				;   Now look after target block.
2652:				;
2653:16650+16	B3D1  2AC6B9  	FNDSPA2	LHLD	DSKSIZE	;is block (DE) within disk limits?
2654:16666+5	B3D4  7B      		MOV	A,E
2655:16671+4	B3D5  95      		SUB	L
2656:16675+5	B3D6  7A      		MOV	A,D
2657:16680+4	B3D7  9C      		SBB	H
2658:16684+10	B3D8  D2F4B3  		JNC	FNDSPA4
2659:16694+5	B3DB  13      		INX	D	;yes, move on to next one.
2660:16699+11	B3DC  C5      		PUSH	B
2661:16710+11	B3DD  D5      		PUSH	D
2662:16721+5	B3DE  42      		MOV	B,D
2663:16726+5	B3DF  4B      		MOV	C,E
2664:16731+17	B3E0  CD35B2  		CALL	CKBITMAP;check it.
2665:16748+4	B3E3  1F      		RAR		;empty?
2666:16752+10	B3E4  D2ECB3  		JNC	FNDSPA3
2667:16762+10	B3E7  D1      		POP	D	;nope, continue searching.
2668:16772+10	B3E8  C1      		POP	B
2669:16782+10	B3E9  C3C0B3  		JMP	FNDSPA1
2670:				;
2671:				;   Empty block found. Set it as used and return with (HL)
2672:				; pointing to it (true?).
2673:				;
2674:16792+4	B3EC  17      	FNDSPA3	RAL		;reset byte.
2675:16796+5	B3ED  3C      		INR	A	;and set bit 0.
2676:16801+17	B3EE  CD64B2  		CALL	STBMAP1	;update bit map.
2677:16818+10	B3F1  E1      		POP	H	;set return registers.
2678:16828+10	B3F2  D1      		POP	D
2679:16838+10	B3F3  C9      		RET
2680:				;
2681:				;   Free block was not found. If (BC) is not zero, then we have
2682:				; not checked all of the disk space.
2683:				;
2684:16848+5	B3F4  79      	FNDSPA4	MOV	A,C
2685:16853+4	B3F5  B0      		ORA	B
2686:16857+10	B3F6  C2C0B3  		JNZ	FNDSPA1
2687:16867+10	B3F9  210000  		LXI	H,0	;set 'not found' status.
2688:16877+10	B3FC  C9      		RET
2689:				;
2690:				;   Move a complete fcb entry into the directory and write it.
2691:				;
2692:16887+7	B3FD  0E00    	FCBSET	MVI	C,0
2693:16894+7	B3FF  1E20    		MVI	E,32	;length of each entry.
2694:				;
2695:				;   Move (E) bytes from the fcb pointed to by (PARAMS) into
2696:				; fcb in directory starting at relative byte (C). This updated
2697:				; directory buffer is then written to the disk.
2698:				;
2699:16901+11	B401  D5      	UPDATE	PUSH	D
2700:16912+7	B402  0600    		MVI	B,0	;set (BC) to relative byte position.
2701:16919+16	B404  2A43AF  		LHLD	PARAMS	;get address of fcb.
2702:16935+10	B407  09      		DAD	B	;compute starting byte.
2703:16945+4	B408  EB      		XCHG
2704:16949+17	B409  CD5EB1  		CALL	FCB2HL	;get address of fcb to update in directory.
2705:16966+10	B40C  C1      		POP	B	;set (C) to number of bytes to change.
2706:16976+17	B40D  CD4FAF  		CALL	DE2HL
2707:16993+17	B410  CDC3AF  	UPDATE1	CALL	TRKSEC	;determine the track and sector affected.
2708:17010+10	B413  C3C6B1  		JMP	DIRWRITE	;then write this sector out.
2709:				;
2710:				;   Routine to change the name of all files on the disk with a
2711:				; specified name. The fcb contains the current name as the
2712:				; first 12 characters and the new name 16 bytes into the fcb.
2713:				;
2714:17020+17	B416  CD54B1  	CHGNAMES:CALL	CHKWPRT	;check for a write protected disk.
2715:17037+7	B419  0E0C    		MVI	C,12	;match first 12 bytes of fcb only.
2716:17044+17	B41B  CD18B3  		CALL	FINDFST	;get first name.
2717:17061+16	B41E  2A43AF  		LHLD	PARAMS	;get address of fcb.
2718:17077+7	B421  7E      		MOV	A,M	;get user number.
2719:17084+10	B422  111000  		LXI	D,16	;move over to desired name.
2720:17094+10	B425  19      		DAD	D
2721:17104+7	B426  77      		MOV	M,A	;keep same user number.
2722:17111+17	B427  CDF5B1  	CHGNAM1	CALL	CKFILPOS;any matching file found?
2723:17128+5+6	B42A  C8      		RZ		;no, we must be done.
2724:17133+17	B42B  CD44B1  		CALL	CHKROFL	;check for read only file.
2725:17150+7	B42E  0E10    		MVI	C,16	;start 16 bytes into fcb.
2726:17157+7	B430  1E0C    		MVI	E,12	;and update the first 12 bytes of directory.
2727:17164+17	B432  CD01B4  		CALL	UPDATE
2728:17181+17	B435  CD2DB3  		CALL	FINDNXT	;get te next file name.
2729:17198+10	B438  C327B4  		JMP	CHGNAM1	;and continue.
2730:				;
2731:				;   Update a files attributes. The procedure is to search for
2732:				; every file with the same name as shown in fcb (ignoring bit 7)
2733:				; and then to update it (which includes bit 7). No other changes
2734:				; are made.
2735:				;
2736:17208+7	B43B  0E0C    	SAVEATTR:MVI	C,12	;match first 12 bytes.
2737:17215+17	B43D  CD18B3  		CALL	FINDFST	;look for first filename.
2738:17232+17	B440  CDF5B1  	SAVATR1	CALL	CKFILPOS;was one found?
2739:17249+5+6	B443  C8      		RZ		;nope, we must be done.
2740:17254+7	B444  0E00    		MVI	C,0	;yes, update the first 12 bytes now.
2741:17261+7	B446  1E0C    		MVI	E,12
2742:17268+17	B448  CD01B4  		CALL	UPDATE	;update filename and write directory.
2743:17285+17	B44B  CD2DB3  		CALL	FINDNXT	;and get the next file.
2744:17302+10	B44E  C340B4  		JMP	SAVATR1	;then continue until done.
2745:				;
2746:				;  Open a file (name specified in fcb).
2747:				;
2748:17312+7	B451  0E0F    	OPENIT	MVI	C,15	;compare the first 15 bytes.
2749:17319+17	B453  CD18B3  		CALL	FINDFST	;get the first one in directory.
2750:17336+17	B456  CDF5B1  		CALL	CKFILPOS;any at all?
2751:17353+5+6	B459  C8      		RZ
2752:17358+17	B45A  CDA6B0  	OPENIT1	CALL	SETEXT	;point to extent byte within users fcb.
2753:17375+7	B45D  7E      		MOV	A,M	;and get it.
2754:17382+11	B45E  F5      		PUSH	PSW	;save it and address.
2755:17393+11	B45F  E5      		PUSH	H
2756:17404+17	B460  CD5EB1  		CALL	FCB2HL	;point to fcb in directory.
2757:17421+4	B463  EB      		XCHG
2758:17425+16	B464  2A43AF  		LHLD	PARAMS	;this is the users copy.
2759:17441+7	B467  0E20    		MVI	C,32	;move it into users space.
2760:17448+11	B469  D5      		PUSH	D
2761:17459+17	B46A  CD4FAF  		CALL	DE2HL
2762:17476+17	B46D  CD78B1  		CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
2763:17493+10	B470  D1      		POP	D	;now get the extent byte from this fcb.
2764:17503+10	B471  210C00  		LXI	H,12
2765:17513+10	B474  19      		DAD	D
2766:17523+7	B475  4E      		MOV	C,M	;into (C).
2767:17530+10	B476  210F00  		LXI	H,15	;now get the record count byte into (B).
2768:17540+10	B479  19      		DAD	D
2769:17550+7	B47A  46      		MOV	B,M
2770:17557+10	B47B  E1      		POP	H	;keep the same extent as the user had originally.
2771:17567+10	B47C  F1      		POP	PSW
2772:17577+7	B47D  77      		MOV	M,A
2773:17584+5	B47E  79      		MOV	A,C	;is it the same as in the directory fcb?
2774:17589+7	B47F  BE      		CMP	M
2775:17596+5	B480  78      		MOV	A,B	;if yes, then use the same record count.
2776:17601+10	B481  CA8BB4  		JZ	OPENIT2
2777:17611+7	B484  3E00    		MVI	A,0	;if the user specified an extent greater than
2778:17618+10	B486  DA8BB4  		JC	OPENIT2	;the one in the directory, then set record count to 0.
2779:17628+7	B489  3E80    		MVI	A,128	;otherwise set to maximum.
2780:17635+16	B48B  2A43AF  	OPENIT2	LHLD	PARAMS	;set record count in users fcb to (A).
2781:17651+10	B48E  110F00  		LXI	D,15
2782:17661+10	B491  19      		DAD	D	;compute relative position.
2783:17671+7	B492  77      		MOV	M,A	;and set the record count.
2784:17678+10	B493  C9      		RET
2785:				;
2786:				;   Move two bytes from (DE) to (HL) if (and only if) (HL)
2787:				; point to a zero value (16 bit).
2788:				;   Return with zero flag set it (DE) was moved. Registers (DE)
2789:				; and (HL) are not changed. However (A) is.
2790:				;
2791:17688+7	B494  7E      	MOVEWORD:MOV	A,M	;check for a zero word.
2792:17695+5	B495  23      		INX	H
2793:17700+7	B496  B6      		ORA	M	;both bytes zero?
2794:17707+5	B497  2B      		DCX	H
2795:17712+5+6	B498  C0      		RNZ		;nope, just return.
2796:17717+7	B499  1A      		LDAX	D	;yes, move two bytes from (DE) into
2797:17724+7	B49A  77      		MOV	M,A	;this zero space.
2798:17731+5	B49B  13      		INX	D
2799:17736+5	B49C  23      		INX	H
2800:17741+7	B49D  1A      		LDAX	D
2801:17748+7	B49E  77      		MOV	M,A
2802:17755+5	B49F  1B      		DCX	D	;don't disturb these registers.
2803:17760+5	B4A0  2B      		DCX	H
2804:17765+10	B4A1  C9      		RET
2805:				;
2806:				;   Get here to close a file specified by (fcb).
2807:				;
2808:17775+4	B4A2  AF      	CLOSEIT	XRA	A	;clear status and file position bytes.
2809:17779+13	B4A3  3245AF  		STA	STATUS
2810:17792+13	B4A6  32EAB9  		STA	FILEPOS
2811:17805+13	B4A9  32EBB9  		STA	FILEPOS+1
2812:17818+17	B4AC  CD1EB1  		CALL	GETWPRT	;get write protect bit for this drive.
2813:17835+5+6	B4AF  C0      		RNZ		;just return if it is set.
2814:17840+17	B4B0  CD69B1  		CALL	GETS2	;else get the 's2' byte.
2815:17857+7	B4B3  E680    		ANI	80H	;and look at bit 7 (file unmodified?).
2816:17864+5+6	B4B5  C0      		RNZ		;just return if set.
2817:17869+7	B4B6  0E0F    		MVI	C,15	;else look up this file in directory.
2818:17876+17	B4B8  CD18B3  		CALL	FINDFST
2819:17893+17	B4BB  CDF5B1  		CALL	CKFILPOS;was it found?
2820:17910+5+6	B4BE  C8      		RZ		;just return if not.
2821:17915+10	B4BF  011000  		LXI	B,16	;set (HL) pointing to records used section.
2822:17925+17	B4C2  CD5EB1  		CALL	FCB2HL
2823:17942+10	B4C5  09      		DAD	B
2824:17952+4	B4C6  EB      		XCHG
2825:17956+16	B4C7  2A43AF  		LHLD	PARAMS	;do the same for users specified fcb.
2826:17972+10	B4CA  09      		DAD	B
2827:17982+7	B4CB  0E10    		MVI	C,16	;this many bytes are present in this extent.
2828:17989+13	B4CD  3ADDB9  	CLOSEIT1:LDA	BIGDISK	;8 or 16 bit record numbers?
2829:18002+4	B4D0  B7      		ORA	A
2830:18006+10	B4D1  CAE8B4  		JZ	CLOSEIT4
2831:18016+7	B4D4  7E      		MOV	A,M	;just 8 bit. Get one from users fcb.
2832:18023+4	B4D5  B7      		ORA	A
2833:18027+7	B4D6  1A      		LDAX	D	;now get one from directory fcb.
2834:18034+10	B4D7  C2DBB4  		JNZ	CLOSEIT2
2835:18044+7	B4DA  77      		MOV	M,A	;users byte was zero. Update from directory.
2836:18051+4	B4DB  B7      	CLOSEIT2:ORA	A
2837:18055+10	B4DC  C2E1B4  		JNZ	CLOSEIT3
2838:18065+7	B4DF  7E      		MOV	A,M	;directories byte was zero, update from users fcb.
2839:18072+7	B4E0  12      		STAX	D
2840:18079+7	B4E1  BE      	CLOSEIT3:CMP	M	;if neither one of these bytes were zero,
2841:18086+10	B4E2  C21FB5  		JNZ	CLOSEIT7	;then close error if they are not the same.
2842:18096+10	B4E5  C3FDB4  		JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
2843:18106+17	B4E8  CD94B4  	CLOSEIT4:CALL	MOVEWORD;update users fcb if it is zero.
2844:18123+4	B4EB  EB      		XCHG
2845:18127+17	B4EC  CD94B4  		CALL	MOVEWORD;update directories fcb if it is zero.
2846:18144+4	B4EF  EB      		XCHG
2847:18148+7	B4F0  1A      		LDAX	D	;if these two values are no different,
2848:18155+7	B4F1  BE      		CMP	M	;then a close error occured.
2849:18162+10	B4F2  C21FB5  		JNZ	CLOSEIT7
2850:18172+5	B4F5  13      		INX	D	;check second byte.
2851:18177+5	B4F6  23      		INX	H
2852:18182+7	B4F7  1A      		LDAX	D
2853:18189+7	B4F8  BE      		CMP	M
2854:18196+10	B4F9  C21FB5  		JNZ	CLOSEIT7
2855:18206+5	B4FC  0D      		DCR	C	;remember 16 bit values.
2856:18211+5	B4FD  13      	CLOSEIT5:INX	D	;bump to next item in table.
2857:18216+5	B4FE  23      		INX	H
2858:18221+5	B4FF  0D      		DCR	C	;there are 16 entries only.
2859:18226+10	B500  C2CDB4  		JNZ	CLOSEIT1;continue if more to do.
2860:18236+10	B503  01ECFF  		LXI	B,0FFECH;backup 20 places (extent byte).
2861:18246+10	B506  09      		DAD	B
2862:18256+4	B507  EB      		XCHG
2863:18260+10	B508  09      		DAD	B
2864:18270+7	B509  1A      		LDAX	D
2865:18277+7	B50A  BE      		CMP	M	;directory's extent already greater than the
2866:18284+10	B50B  DA17B5  		JC	CLOSEIT6	;users extent?
2867:18294+7	B50E  77      		MOV	M,A	;no, update directory extent.
2868:18301+10	B50F  010300  		LXI	B,3	;and update the record count byte in
2869:18311+10	B512  09      		DAD	B	;directories fcb.
2870:18321+4	B513  EB      		XCHG
2871:18325+10	B514  09      		DAD	B
2872:18335+7	B515  7E      		MOV	A,M	;get from user.
2873:18342+7	B516  12      		STAX	D	;and put in directory.
2874:18349+7	B517  3EFF    	CLOSEIT6:MVI	A,0FFH	;set 'was open and is now closed' byte.
2875:18356+13	B519  32D2B9  		STA	CLOSEFLG
2876:18369+10	B51C  C310B4  		JMP	UPDATE1	;update the directory now.
2877:18379+10	B51F  2145AF  	CLOSEIT7:LXI	H,STATUS;set return status and then return.
2878:18389+10	B522  35      		DCR	M
2879:18399+10	B523  C9      		RET
2880:				;
2881:				;   Routine to get the next empty space in the directory. It
2882:				; will then be cleared for use.
2883:				;
2884:18409+17	B524  CD54B1  	GETEMPTY:CALL	CHKWPRT	;make sure disk is not write protected.
2885:18426+16	B527  2A43AF  		LHLD	PARAMS	;save current parameters (fcb).
2886:18442+11	B52A  E5      		PUSH	H
2887:18453+10	B52B  21ACB9  		LXI	H,EMPTYFCB;use special one for empty space.
2888:18463+16	B52E  2243AF  		SHLD	PARAMS
2889:18479+7	B531  0E01    		MVI	C,1	;search for first empty spot in directory.
2890:18486+17	B533  CD18B3  		CALL	FINDFST	;(* only check first byte *)
2891:18503+17	B536  CDF5B1  		CALL	CKFILPOS;none?
2892:18520+10	B539  E1      		POP	H
2893:18530+16	B53A  2243AF  		SHLD	PARAMS	;restore original fcb address.
2894:18546+5+6	B53D  C8      		RZ		;return if no more space.
2895:18551+4	B53E  EB      		XCHG
2896:18555+10	B53F  210F00  		LXI	H,15	;point to number of records for this file.
2897:18565+10	B542  19      		DAD	D
2898:18575+7	B543  0E11    		MVI	C,17	;and clear all of this space.
2899:18582+4	B545  AF      		XRA	A
2900:18586+7	B546  77      	GETMT1	MOV	M,A
2901:18593+5	B547  23      		INX	H
2902:18598+5	B548  0D      		DCR	C
2903:18603+10	B549  C246B5  		JNZ	GETMT1
2904:18613+10	B54C  210D00  		LXI	H,13	;clear the 's1' byte also.
2905:18623+10	B54F  19      		DAD	D
2906:18633+7	B550  77      		MOV	M,A
2907:18640+17	B551  CD8CB1  		CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
2908:18657+17	B554  CDFDB3  		CALL	FCBSET	;write out this fcb entry to directory.
2909:18674+10	B557  C378B1  		JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
2910:				;
2911:				;   Routine to close the current extent and open the next one
2912:				; for reading.
2913:				;
2914:18684+4	B55A  AF      	GETNEXT	XRA	A
2915:18688+13	B55B  32D2B9  		STA	CLOSEFLG;clear close flag.
2916:18701+17	B55E  CDA2B4  		CALL	CLOSEIT	;close this extent.
2917:18718+17	B561  CDF5B1  		CALL	CKFILPOS
2918:18735+5+6	B564  C8      		RZ		;not there???
2919:18740+16	B565  2A43AF  		LHLD	PARAMS	;get extent byte.
2920:18756+10	B568  010C00  		LXI	B,12
2921:18766+10	B56B  09      		DAD	B
2922:18776+7	B56C  7E      		MOV	A,M	;and increment it.
2923:18783+5	B56D  3C      		INR	A
2924:18788+7	B56E  E61F    		ANI	1FH	;keep within range 0-31.
2925:18795+7	B570  77      		MOV	M,A
2926:18802+10	B571  CA83B5  		JZ	GTNEXT1	;overflow?
2927:18812+5	B574  47      		MOV	B,A	;mask extent byte.
2928:18817+13	B575  3AC5B9  		LDA	EXTMASK
2929:18830+4	B578  A0      		ANA	B
2930:18834+10	B579  21D2B9  		LXI	H,CLOSEFLG;check close flag (0ffh is ok).
2931:18844+7	B57C  A6      		ANA	M
2932:18851+10	B57D  CA8EB5  		JZ	GTNEXT2	;if zero, we must read in next extent.
2933:18861+10	B580  C3ACB5  		JMP	GTNEXT3	;else, it is already in memory.
2934:18871+10	B583  010200  	GTNEXT1	LXI	B,2	;Point to the 's2' byte.
2935:18881+10	B586  09      		DAD	B
2936:18891+10	B587  34      		INR	M	;and bump it.
2937:18901+7	B588  7E      		MOV	A,M	;too many extents?
2938:18908+7	B589  E60F    		ANI	0FH
2939:18915+10	B58B  CAB6B5  		JZ	GTNEXT5	;yes, set error code.
2940:				;
2941:				;   Get here to open the next extent.
2942:				;
2943:18925+7	B58E  0E0F    	GTNEXT2	MVI	C,15	;set to check first 15 bytes of fcb.
2944:18932+17	B590  CD18B3  		CALL	FINDFST	;find the first one.
2945:18949+17	B593  CDF5B1  		CALL	CKFILPOS;none available?
2946:18966+10	B596  C2ACB5  		JNZ	GTNEXT3
2947:18976+13	B599  3AD3B9  		LDA	RDWRTFLG;no extent present. Can we open an empty one?
2948:18989+5	B59C  3C      		INR	A	;0ffh means reading (so not possible).
2949:18994+10	B59D  CAB6B5  		JZ	GTNEXT5	;or an error.
2950:19004+17	B5A0  CD24B5  		CALL	GETEMPTY;we are writing, get an empty entry.
2951:19021+17	B5A3  CDF5B1  		CALL	CKFILPOS;none?
2952:19038+10	B5A6  CAB6B5  		JZ	GTNEXT5	;error if true.
2953:19048+10	B5A9  C3AFB5  		JMP	GTNEXT4	;else we are almost done.
2954:19058+17	B5AC  CD5AB4  	GTNEXT3	CALL	OPENIT1	;open this extent.
2955:19075+17	B5AF  CDBBB0  	GTNEXT4	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
2956:19092+4	B5B2  AF      		XRA	A	;clear status and return.
2957:19096+10	B5B3  C301AF  		JMP	SETSTAT
2958:				;
2959:				;   Error in extending the file. Too many extents were needed
2960:				; or not enough space on the disk.
2961:				;
2962:19106+17	B5B6  CD05AF  	GTNEXT5	CALL	IOERR1	;set error code, clear bit 7 of 's2'
2963:19123+10	B5B9  C378B1  		JMP	SETS2B7	;so this is not written on a close.
2964:				;
2965:				;   Read a sequential file.
2966:				;
2967:19133+7	B5BC  3E01    	RDSEQ	MVI	A,1	;set sequential access mode.
2968:19140+13	B5BE  32D5B9  		STA	MODE
2969:19153+7	B5C1  3EFF    	RDSEQ1	MVI	A,0FFH	;don't allow reading unwritten space.
2970:19160+13	B5C3  32D3B9  		STA	RDWRTFLG
2971:19173+17	B5C6  CDBBB0  		CALL	STRDATA	;put rec# and ext# into fcb.
2972:19190+13	B5C9  3AE3B9  		LDA	SAVNREC	;get next record to read.
2973:19203+10	B5CC  21E1B9  		LXI	H,SAVNXT;get number of records in extent.
2974:19213+7	B5CF  BE      		CMP	M	;within this extent?
2975:19220+10	B5D0  DAE6B5  		JC	RDSEQ2
2976:19230+7	B5D3  FE80    		CPI	128	;no. Is this extent fully used?
2977:19237+10	B5D5  C2FBB5  		JNZ	RDSEQ3	;no. End-of-file.
2978:19247+17	B5D8  CD5AB5  		CALL	GETNEXT	;yes, open the next one.
2979:19264+4	B5DB  AF      		XRA	A	;reset next record to read.
2980:19268+13	B5DC  32E3B9  		STA	SAVNREC
2981:19281+13	B5DF  3A45AF  		LDA	STATUS	;check on open, successful?
2982:19294+4	B5E2  B7      		ORA	A
2983:19298+10	B5E3  C2FBB5  		JNZ	RDSEQ3	;no, error.
2984:19308+17	B5E6  CD77B0  	RDSEQ2	CALL	COMBLK	;ok. compute block number to read.
2985:19325+17	B5E9  CD84B0  		CALL	CHKBLK	;check it. Within bounds?
2986:19342+10	B5EC  CAFBB5  		JZ	RDSEQ3	;no, error.
2987:19352+17	B5EF  CD8AB0  		CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
2988:19369+17	B5F2  CDD1AF  		CALL	TRKSEC1	;set the track and sector for this block #.
2989:19386+17	B5F5  CDB2AF  		CALL	DOREAD	;and read it.
2990:19403+10	B5F8  C3D2B0  		JMP	SETNREC	;and set the next record to be accessed.
2991:				;
2992:				;   Read error occured. Set status and return.
2993:				;
2994:19413+10	B5FB  C305AF  	RDSEQ3	JMP	IOERR1
2995:				;
2996:				;   Write the next sequential record.
2997:				;
2998:19423+7	B5FE  3E01    	WTSEQ	MVI	A,1	;set sequential access mode.
2999:19430+13	B600  32D5B9  		STA	MODE
3000:19443+7	B603  3E00    	WTSEQ1	MVI	A,0	;allow an addition empty extent to be opened.
3001:19450+13	B605  32D3B9  		STA	RDWRTFLG
3002:19463+17	B608  CD54B1  		CALL	CHKWPRT	;check write protect status.
3003:19480+16	B60B  2A43AF  		LHLD	PARAMS
3004:19496+17	B60E  CD47B1  		CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3005:19513+17	B611  CDBBB0  		CALL	STRDATA	;put updated data into fcb.
3006:19530+13	B614  3AE3B9  		LDA	SAVNREC	;get record number to write.
3007:19543+7	B617  FE80    		CPI	128	;within range?
3008:19550+10	B619  D205AF  		JNC	IOERR1	;no, error(?).
3009:19560+17	B61C  CD77B0  		CALL	COMBLK	;compute block number.
3010:19577+17	B61F  CD84B0  		CALL	CHKBLK	;check number.
3011:19594+7	B622  0E00    		MVI	C,0	;is there one to write to?
3012:19601+10	B624  C26EB6  		JNZ	WTSEQ6	;yes, go do it.
3013:19611+17	B627  CD3EB0  		CALL	GETBLOCK;get next block number within fcb to use.
3014:19628+13	B62A  32D7B9  		STA	RELBLOCK;and save.
3015:19641+10	B62D  010000  		LXI	B,0	;start looking for space from the start
3016:19651+4	B630  B7      		ORA	A	;if none allocated as yet.
3017:19655+10	B631  CA3BB6  		JZ	WTSEQ2
3018:19665+5	B634  4F      		MOV	C,A	;extract previous block number from fcb
3019:19670+5	B635  0B      		DCX	B	;so we can be closest to it.
3020:19675+17	B636  CD5EB0  		CALL	EXTBLK
3021:19692+5	B639  44      		MOV	B,H
3022:19697+5	B63A  4D      		MOV	C,L
3023:19702+17	B63B  CDBEB3  	WTSEQ2	CALL	FNDSPACE;find the next empty block nearest number (BC).
3024:19719+5	B63E  7D      		MOV	A,L	;check for a zero number.
3025:19724+4	B63F  B4      		ORA	H
3026:19728+10	B640  C248B6  		JNZ	WTSEQ3
3027:19738+7	B643  3E02    		MVI	A,2	;no more space?
3028:19745+10	B645  C301AF  		JMP	SETSTAT
3029:19755+16	B648  22E5B9  	WTSEQ3	SHLD	BLKNMBR	;save block number to access.
3030:19771+4	B64B  EB      		XCHG		;put block number into (DE).
3031:19775+16	B64C  2A43AF  		LHLD	PARAMS	;now we must update the fcb for this
3032:19791+10	B64F  011000  		LXI	B,16	;newly allocated block.
3033:19801+10	B652  09      		DAD	B
3034:19811+13	B653  3ADDB9  		LDA	BIGDISK	;8 or 16 bit block numbers?
3035:19824+4	B656  B7      		ORA	A
3036:19828+13	B657  3AD7B9  		LDA	RELBLOCK	;(* update this entry *)
3037:19841+10	B65A  CA64B6  		JZ	WTSEQ4	;zero means 16 bit ones.
3038:19851+17	B65D  CD64B1  		CALL	ADDA2HL	;(HL)=(HL)+(A)
3039:19868+7	B660  73      		MOV	M,E	;store new block number.
3040:19875+10	B661  C36CB6  		JMP	WTSEQ5
3041:19885+5	B664  4F      	WTSEQ4	MOV	C,A	;compute spot in this 16 bit table.
3042:19890+7	B665  0600    		MVI	B,0
3043:19897+10	B667  09      		DAD	B
3044:19907+10	B668  09      		DAD	B
3045:19917+7	B669  73      		MOV	M,E	;stuff block number (DE) there.
3046:19924+5	B66A  23      		INX	H
3047:19929+7	B66B  72      		MOV	M,D
3048:19936+7	B66C  0E02    	WTSEQ5	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3049:19943+13	B66E  3A45AF  	WTSEQ6	LDA	STATUS	;are we ok so far?
3050:19956+4	B671  B7      		ORA	A
3051:19960+5+6	B672  C0      		RNZ
3052:19965+11	B673  C5      		PUSH	B	;yes, save write flag for bios (register C).
3053:19976+17	B674  CD8AB0  		CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
3054:19993+13	B677  3AD5B9  		LDA	MODE	;get access mode flag (1=sequential,
3055:20006+5	B67A  3D      		DCR	A	;0=random, 2=special?).
3056:20011+5	B67B  3D      		DCR	A
3057:20016+10	B67C  C2BBB6  		JNZ	WTSEQ9
3058:				;
3059:				;   Special random i/o from function #40. Maybe for M/PM, but the
3060:				; current block, if it has not been written to, will be zeroed
3061:				; out and then written (reason?).
3062:				;
3063:20026+10	B67F  C1      		POP	B
3064:20036+11	B680  C5      		PUSH	B
3065:20047+5	B681  79      		MOV	A,C	;get write status flag (2=writing unused space).
3066:20052+5	B682  3D      		DCR	A
3067:20057+5	B683  3D      		DCR	A
3068:20062+10	B684  C2BBB6  		JNZ	WTSEQ9
3069:20072+11	B687  E5      		PUSH	H
3070:20083+16	B688  2AB9B9  		LHLD	DIRBUF	;zero out the directory buffer.
3071:20099+5	B68B  57      		MOV	D,A	;note that (A) is zero here.
3072:20104+7	B68C  77      	WTSEQ7	MOV	M,A
3073:20111+5	B68D  23      		INX	H
3074:20116+5	B68E  14      		INR	D	;do 128 bytes.
3075:20121+10	B68F  F28CB6  		JP	WTSEQ7
3076:20131+17	B692  CDE0B1  		CALL	DIRDMA	;tell the bios the dma address for directory access.
3077:20148+16	B695  2AE7B9  		LHLD	LOGSECT	;get sector that starts current block.
3078:20164+7	B698  0E02    		MVI	C,2	;set 'writing to unused space' flag.
3079:20171+16	B69A  22E5B9  	WTSEQ8	SHLD	BLKNMBR	;save sector to write.
3080:20187+11	B69D  C5      		PUSH	B
3081:20198+17	B69E  CDD1AF  		CALL	TRKSEC1	;determine its track and sector numbers.
3082:20215+10	B6A1  C1      		POP	B
3083:20225+17	B6A2  CDB8AF  		CALL	DOWRITE	;now write out 128 bytes of zeros.
3084:20242+16	B6A5  2AE5B9  		LHLD	BLKNMBR	;get sector number.
3085:20258+7	B6A8  0E00    		MVI	C,0	;set normal write flag.
3086:20265+13	B6AA  3AC4B9  		LDA	BLKMASK	;determine if we have written the entire
3087:20278+5	B6AD  47      		MOV	B,A	;physical block.
3088:20283+4	B6AE  A5      		ANA	L
3089:20287+4	B6AF  B8      		CMP	B
3090:20291+5	B6B0  23      		INX	H	;prepare for the next one.
3091:20296+10	B6B1  C29AB6  		JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3092:20306+10	B6B4  E1      		POP	H	;reset next sector number.
3093:20316+16	B6B5  22E5B9  		SHLD	BLKNMBR
3094:20332+17	B6B8  CDDAB1  		CALL	DEFDMA	;and reset dma address.
3095:				;
3096:				;   Normal disk write. Set the desired track and sector then
3097:				; do the actual write.
3098:				;
3099:20349+17	B6BB  CDD1AF  	WTSEQ9	CALL	TRKSEC1	;determine track and sector for this write.
3100:20366+10	B6BE  C1      		POP	B	;get write status flag.
3101:20376+11	B6BF  C5      		PUSH	B
3102:20387+17	B6C0  CDB8AF  		CALL	DOWRITE	;and write this out.
3103:20404+10	B6C3  C1      		POP	B
3104:20414+13	B6C4  3AE3B9  		LDA	SAVNREC	;get number of records in file.
3105:20427+10	B6C7  21E1B9  		LXI	H,SAVNXT;get last record written.
3106:20437+7	B6CA  BE      		CMP	M
3107:20444+10	B6CB  DAD2B6  		JC	WTSEQ10
3108:20454+7	B6CE  77      		MOV	M,A	;we have to update record count.
3109:20461+10	B6CF  34      		INR	M
3110:20471+7	B6D0  0E02    		MVI	C,2
3111:				;
3112:				;*   This area has been patched to correct disk update problem
3113:				;* when using blocking and de-blocking in the BIOS.
3114:				;
3115:20478+4	B6D2  00      	WTSEQ10	NOP		;was 'dcr c'
3116:20482+4	B6D3  00      		NOP		;was 'dcr c'
3117:20486+10	B6D4  210000  		LXI	H,0	;was 'jnz wtseq99'
3118:				;
3119:				; *   End of patch.
3120:				;
3121:20496+11	B6D7  F5      		PUSH	PSW
3122:20507+17	B6D8  CD69B1  		CALL	GETS2	;set 'extent written to' flag.
3123:20524+7	B6DB  E67F    		ANI	7FH	;(* clear bit 7 *)
3124:20531+7	B6DD  77      		MOV	M,A
3125:20538+10	B6DE  F1      		POP	PSW	;get record count for this extent.
3126:20548+7	B6DF  FE7F    	WTSEQ99	CPI	127	;is it full?
3127:20555+10	B6E1  C200B7  		JNZ	WTSEQ12
3128:20565+13	B6E4  3AD5B9  		LDA	MODE	;yes, are we in sequential mode?
3129:20578+7	B6E7  FE01    		CPI	1
3130:20585+10	B6E9  C200B7  		JNZ	WTSEQ12
3131:20595+17	B6EC  CDD2B0  		CALL	SETNREC	;yes, set next record number.
3132:20612+17	B6EF  CD5AB5  		CALL	GETNEXT	;and get next empty space in directory.
3133:20629+10	B6F2  2145AF  		LXI	H,STATUS;ok?
3134:20639+7	B6F5  7E      		MOV	A,M
3135:20646+4	B6F6  B7      		ORA	A
3136:20650+10	B6F7  C2FEB6  		JNZ	WTSEQ11
3137:20660+5	B6FA  3D      		DCR	A	;yes, set record count to -1.
3138:20665+13	B6FB  32E3B9  		STA	SAVNREC
3139:20678+10	B6FE  3600    	WTSEQ11	MVI	M,0	;clear status.
3140:20688+10	B700  C3D2B0  	WTSEQ12	JMP	SETNREC	;set next record to access.
3141:				;
3142:				;   For random i/o, set the fcb for the desired record number
3143:				; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3144:				; used as follows:
3145:				;
3146:				;       fcb+35            fcb+34            fcb+33
3147:				;  |     'r-2'      |      'r-1'      |      'r-0'     |
3148:				;  |7             0 | 7             0 | 7             0|
3149:				;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3150:				;  |    overflow   | | extra |  extent   |   record #  |
3151:				;  | ______________| |_extent|__number___|_____________|
3152:				;                     also 's2'
3153:				;
3154:				;   On entry, register (C) contains 0ffh if this is a read
3155:				; and thus we can not access unwritten disk space. Otherwise,
3156:				; another extent will be opened (for writing) if required.
3157:				;
3158:20698+4	B703  AF      	POSITION:XRA	A	;set random i/o flag.
3159:20702+13	B704  32D5B9  		STA	MODE
3160:				;
3161:				;   Special entry (function #40). M/PM ?
3162:				;
3163:20715+11	B707  C5      	POSITN1	PUSH	B	;save read/write flag.
3164:20726+16	B708  2A43AF  		LHLD	PARAMS	;get address of fcb.
3165:20742+4	B70B  EB      		XCHG
3166:20746+10	B70C  212100  		LXI	H,33	;now get byte 'r0'.
3167:20756+10	B70F  19      		DAD	D
3168:20766+7	B710  7E      		MOV	A,M
3169:20773+7	B711  E67F    		ANI	7FH	;keep bits 0-6 for the record number to access.
3170:20780+11	B713  F5      		PUSH	PSW
3171:20791+7	B714  7E      		MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3172:20798+4	B715  17      		RAL
3173:20802+5	B716  23      		INX	H
3174:20807+7	B717  7E      		MOV	A,M
3175:20814+4	B718  17      		RAL
3176:20818+7	B719  E61F    		ANI	1FH	;and save this in bits 0-4 of (C).
3177:20825+5	B71B  4F      		MOV	C,A	;this is the extent byte.
3178:20830+7	B71C  7E      		MOV	A,M	;now get the extra extent byte.
3179:20837+4	B71D  1F      		RAR
3180:20841+4	B71E  1F      		RAR
3181:20845+4	B71F  1F      		RAR
3182:20849+4	B720  1F      		RAR
3183:20853+7	B721  E60F    		ANI	0FH
3184:20860+5	B723  47      		MOV	B,A	;and save it in (B).
3185:20865+10	B724  F1      		POP	PSW	;get record number back to (A).
3186:20875+5	B725  23      		INX	H	;check overflow byte 'r2'.
3187:20880+7	B726  6E      		MOV	L,M
3188:20887+5	B727  2C      		INR	L
3189:20892+5	B728  2D      		DCR	L
3190:20897+7	B729  2E06    		MVI	L,6	;prepare for error.
3191:20904+10	B72B  C28BB7  		JNZ	POSITN5	;out of disk space error.
3192:20914+10	B72E  212000  		LXI	H,32	;store record number into fcb.
3193:20924+10	B731  19      		DAD	D
3194:20934+7	B732  77      		MOV	M,A
3195:20941+10	B733  210C00  		LXI	H,12	;and now check the extent byte.
3196:20951+10	B736  19      		DAD	D
3197:20961+5	B737  79      		MOV	A,C
3198:20966+7	B738  96      		SUB	M	;same extent as before?
3199:20973+10	B739  C247B7  		JNZ	POSITN2
3200:20983+10	B73C  210E00  		LXI	H,14	;yes, check extra extent byte 's2' also.
3201:20993+10	B73F  19      		DAD	D
3202:21003+5	B740  78      		MOV	A,B
3203:21008+7	B741  96      		SUB	M
3204:21015+7	B742  E67F    		ANI	7FH
3205:21022+10	B744  CA7FB7  		JZ	POSITN3;same, we are almost done then.
3206:				;
3207:				;  Get here when another extent is required.
3208:				;
3209:21032+11	B747  C5      	POSITN2	PUSH	B
3210:21043+11	B748  D5      		PUSH	D
3211:21054+17	B749  CDA2B4  		CALL	CLOSEIT	;close current extent.
3212:21071+10	B74C  D1      		POP	D
3213:21081+10	B74D  C1      		POP	B
3214:21091+7	B74E  2E03    		MVI	L,3	;prepare for error.
3215:21098+13	B750  3A45AF  		LDA	STATUS
3216:21111+5	B753  3C      		INR	A
3217:21116+10	B754  CA84B7  		JZ	POSITN4	;close error.
3218:21126+10	B757  210C00  		LXI	H,12	;put desired extent into fcb now.
3219:21136+10	B75A  19      		DAD	D
3220:21146+7	B75B  71      		MOV	M,C
3221:21153+10	B75C  210E00  		LXI	H,14	;and store extra extent byte 's2'.
3222:21163+10	B75F  19      		DAD	D
3223:21173+7	B760  70      		MOV	M,B
3224:21180+17	B761  CD51B4  		CALL	OPENIT	;try and get this extent.
3225:21197+13	B764  3A45AF  		LDA	STATUS	;was it there?
3226:21210+5	B767  3C      		INR	A
3227:21215+10	B768  C27FB7  		JNZ	POSITN3
3228:21225+10	B76B  C1      		POP	B	;no. can we create a new one (writing?).
3229:21235+11	B76C  C5      		PUSH	B
3230:21246+7	B76D  2E04    		MVI	L,4	;prepare for error.
3231:21253+5	B76F  0C      		INR	C
3232:21258+10	B770  CA84B7  		JZ	POSITN4	;nope, reading unwritten space error.
3233:21268+17	B773  CD24B5  		CALL	GETEMPTY;yes we can, try to find space.
3234:21285+7	B776  2E05    		MVI	L,5	;prepare for error.
3235:21292+13	B778  3A45AF  		LDA	STATUS
3236:21305+5	B77B  3C      		INR	A
3237:21310+10	B77C  CA84B7  		JZ	POSITN4	;out of space?
3238:				;
3239:				;   Normal return location. Clear error code and return.
3240:				;
3241:21320+10	B77F  C1      	POSITN3	POP	B	;restore stack.
3242:21330+4	B780  AF      		XRA	A	;and clear error code byte.
3243:21334+10	B781  C301AF  		JMP	SETSTAT
3244:				;
3245:				;   Error. Set the 's2' byte to indicate this (why?).
3246:				;
3247:21344+11	B784  E5      	POSITN4	PUSH	H
3248:21355+17	B785  CD69B1  		CALL	GETS2
3249:21372+10	B788  36C0    		MVI	M,0C0H
3250:21382+10	B78A  E1      		POP	H
3251:				;
3252:				;   Return with error code (presently in L).
3253:				;
3254:21392+10	B78B  C1      	POSITN5	POP	B
3255:21402+5	B78C  7D      		MOV	A,L	;get error code.
3256:21407+13	B78D  3245AF  		STA	STATUS
3257:21420+10	B790  C378B1  		JMP	SETS2B7
3258:				;
3259:				;   Read a random record.
3260:				;
3261:21430+7	B793  0EFF    	READRAN	MVI	C,0FFH	;set 'read' status.
3262:21437+17	B795  CD03B7  		CALL	POSITION;position the file to proper record.
3263:21454+11+6	B798  CCC1B5  		CZ	RDSEQ1	;and read it as usual (if no errors).
3264:21465+10	B79B  C9      		RET
3265:				;
3266:				;   Write to a random record.
3267:				;
3268:21475+7	B79C  0E00    	WRITERAN:MVI	C,0	;set 'writing' flag.
3269:21482+17	B79E  CD03B7  		CALL	POSITION;position the file to proper record.
3270:21499+11+6	B7A1  CC03B6  		CZ	WTSEQ1	;and write as usual (if no errors).
3271:21510+10	B7A4  C9      		RET
3272:				;
3273:				;   Compute the random record number. Enter with (HL) pointing
3274:				; to a fcb an (DE) contains a relative location of a record
3275:				; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3276:				; byte, and (A) the 'r2' byte.
3277:				;
3278:				;   On return, the zero flag is set if the record is within
3279:				; bounds. Otherwise, an overflow occured.
3280:				;
3281:21520+4	B7A5  EB      	COMPRAND:XCHG		;save fcb pointer in (DE).
3282:21524+10	B7A6  19      		DAD	D	;compute relative position of record #.
3283:21534+7	B7A7  4E      		MOV	C,M	;get record number into (BC).
3284:21541+7	B7A8  0600    		MVI	B,0
3285:21548+10	B7AA  210C00  		LXI	H,12	;now get extent.
3286:21558+10	B7AD  19      		DAD	D
3287:21568+7	B7AE  7E      		MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3288:21575+4	B7AF  0F      		RRC		;move lower bit into bit 7.
3289:21579+7	B7B0  E680    		ANI	80H	;and ignore all other bits.
3290:21586+4	B7B2  81      		ADD	C	;add to our record number.
3291:21590+5	B7B3  4F      		MOV	C,A
3292:21595+7	B7B4  3E00    		MVI	A,0	;take care of any carry.
3293:21602+4	B7B6  88      		ADC	B
3294:21606+5	B7B7  47      		MOV	B,A
3295:21611+7	B7B8  7E      		MOV	A,M	;now get the upper bits of extent into
3296:21618+4	B7B9  0F      		RRC		;bit positions 0-3.
3297:21622+7	B7BA  E60F    		ANI	0FH	;and ignore all others.
3298:21629+4	B7BC  80      		ADD	B	;add this in to 'r1' byte.
3299:21633+5	B7BD  47      		MOV	B,A
3300:21638+10	B7BE  210E00  		LXI	H,14	;get the 's2' byte (extra extent).
3301:21648+10	B7C1  19      		DAD	D
3302:21658+7	B7C2  7E      		MOV	A,M
3303:21665+4	B7C3  87      		ADD	A	;and shift it left 4 bits (bits 4-7).
3304:21669+4	B7C4  87      		ADD	A
3305:21673+4	B7C5  87      		ADD	A
3306:21677+4	B7C6  87      		ADD	A
3307:21681+11	B7C7  F5      		PUSH	PSW	;save carry flag (bit 0 of flag byte).
3308:21692+4	B7C8  80      		ADD	B	;now add extra extent into 'r1'.
3309:21696+5	B7C9  47      		MOV	B,A
3310:21701+11	B7CA  F5      		PUSH	PSW	;and save carry (overflow byte 'r2').
3311:21712+10	B7CB  E1      		POP	H	;bit 0 of (L) is the overflow indicator.
3312:21722+5	B7CC  7D      		MOV	A,L
3313:21727+10	B7CD  E1      		POP	H	;and same for first carry flag.
3314:21737+4	B7CE  B5      		ORA	L	;either one of these set?
3315:21741+7	B7CF  E601    		ANI	01H	;only check the carry flags.
3316:21748+10	B7D1  C9      		RET
3317:				;
3318:				;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3319:				; reflect the last record used for a random (or other) file.
3320:				; This reads the directory and looks at all extents computing
3321:				; the largerst record number for each and keeping the maximum
3322:				; value only. Then 'r0', 'r1', and 'r2' will reflect this
3323:				; maximum record number. This is used to compute the space used
3324:				; by a random file.
3325:				;
3326:21758+7	B7D2  0E0C    	RANSIZE	MVI	C,12	;look thru directory for first entry with
3327:21765+17	B7D4  CD18B3  		CALL	FINDFST	;this name.
3328:21782+16	B7D7  2A43AF  		LHLD	PARAMS	;zero out the 'r0, r1, r2' bytes.
3329:21798+10	B7DA  112100  		LXI	D,33
3330:21808+10	B7DD  19      		DAD	D
3331:21818+11	B7DE  E5      		PUSH	H
3332:21829+7	B7DF  72      		MOV	M,D	;note that (D)=0.
3333:21836+5	B7E0  23      		INX	H
3334:21841+7	B7E1  72      		MOV	M,D
3335:21848+5	B7E2  23      		INX	H
3336:21853+7	B7E3  72      		MOV	M,D
3337:21860+17	B7E4  CDF5B1  	RANSIZ1	CALL	CKFILPOS;is there an extent to process?
3338:21877+10	B7E7  CA0CB8  		JZ	RANSIZ3	;no, we are done.
3339:21887+17	B7EA  CD5EB1  		CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3340:21904+10	B7ED  110F00  		LXI	D,15	;point to last record in extent.
3341:21914+17	B7F0  CDA5B7  		CALL	COMPRAND;and compute random parameters.
3342:21931+10	B7F3  E1      		POP	H
3343:21941+11	B7F4  E5      		PUSH	H	;now check these values against those
3344:21952+5	B7F5  5F      		MOV	E,A	;already in fcb.
3345:21957+5	B7F6  79      		MOV	A,C	;the carry flag will be set if those
3346:21962+7	B7F7  96      		SUB	M	;in the fcb represent a larger size than
3347:21969+5	B7F8  23      		INX	H	;this extent does.
3348:21974+5	B7F9  78      		MOV	A,B
3349:21979+7	B7FA  9E      		SBB	M
3350:21986+5	B7FB  23      		INX	H
3351:21991+5	B7FC  7B      		MOV	A,E
3352:21996+7	B7FD  9E      		SBB	M
3353:22003+10	B7FE  DA06B8  		JC	RANSIZ2
3354:22013+7	B801  73      		MOV	M,E	;we found a larger (in size) extent.
3355:22020+5	B802  2B      		DCX	H	;stuff these values into fcb.
3356:22025+7	B803  70      		MOV	M,B
3357:22032+5	B804  2B      		DCX	H
3358:22037+7	B805  71      		MOV	M,C
3359:22044+17	B806  CD2DB3  	RANSIZ2	CALL	FINDNXT	;now get the next extent.
3360:22061+10	B809  C3E4B7  		JMP	RANSIZ1	;continue til all done.
3361:22071+10	B80C  E1      	RANSIZ3	POP	H	;we are done, restore the stack and
3362:22081+10	B80D  C9      		RET		;return.
3363:				;
3364:				;   Function to return the random record position of a given
3365:				; file which has been read in sequential mode up to now.
3366:				;
3367:22091+16	B80E  2A43AF  	SETRAN	LHLD	PARAMS	;point to fcb.
3368:22107+10	B811  112000  		LXI	D,32	;and to last used record.
3369:22117+17	B814  CDA5B7  		CALL	COMPRAND;compute random position.
3370:22134+10	B817  212100  		LXI	H,33	;now stuff these values into fcb.
3371:22144+10	B81A  19      		DAD	D
3372:22154+7	B81B  71      		MOV	M,C	;move 'r0'.
3373:22161+5	B81C  23      		INX	H
3374:22166+7	B81D  70      		MOV	M,B	;and 'r1'.
3375:22173+5	B81E  23      		INX	H
3376:22178+7	B81F  77      		MOV	M,A	;and lastly 'r2'.
3377:22185+10	B820  C9      		RET
3378:				;
3379:				;   This routine select the drive specified in (ACTIVE) and
3380:				; update the login vector and bitmap table if this drive was
3381:				; not already active.
3382:				;
3383:22195+16	B821  2AAFB9  	LOGINDRV:LHLD	LOGIN	;get the login vector.
3384:22211+13	B824  3A42AF  		LDA	ACTIVE	;get the default drive.
3385:22224+5	B827  4F      		MOV	C,A
3386:22229+17	B828  CDEAB0  		CALL	SHIFTR	;position active bit for this drive
3387:22246+11	B82B  E5      		PUSH	H	;into bit 0.
3388:22257+4	B82C  EB      		XCHG
3389:22261+17	B82D  CD59AF  		CALL	SELECT	;select this drive.
3390:22278+10	B830  E1      		POP	H
3391:22288+11+6	B831  CC47AF  		CZ	SLCTERR	;valid drive?
3392:22299+5	B834  7D      		MOV	A,L	;is this a newly activated drive?
3393:22304+4	B835  1F      		RAR
3394:22308+5+6	B836  D8      		RC
3395:22313+16	B837  2AAFB9  		LHLD	LOGIN	;yes, update the login vector.
3396:22329+5	B83A  4D      		MOV	C,L
3397:22334+5	B83B  44      		MOV	B,H
3398:22339+17	B83C  CD0BB1  		CALL	SETBIT
3399:22356+16	B83F  22AFB9  		SHLD	LOGIN	;and save.
3400:22372+10	B842  C3A3B2  		JMP	BITMAP	;now update the bitmap.
3401:				;
3402:				;   Function to set the active disk number.
3403:				;
3404:22382+13	B845  3AD6B9  	SETDSK	LDA	EPARAM	;get parameter passed and see if this
3405:22395+10	B848  2142AF  		LXI	H,ACTIVE;represents a change in drives.
3406:22405+7	B84B  BE      		CMP	M
3407:22412+5+6	B84C  C8      		RZ
3408:22417+7	B84D  77      		MOV	M,A	;yes it does, log it in.
3409:22424+10	B84E  C321B8  		JMP	LOGINDRV
3410:				;
3411:				;   This is the 'auto disk select' routine. The firsst byte
3412:				; of the fcb is examined for a drive specification. If non
3413:				; zero then the drive will be selected and loged in.
3414:				;
3415:22434+7	B851  3EFF    	AUTOSEL	MVI	A,0FFH	;say 'auto-select activated'.
3416:22441+13	B853  32DEB9  		STA	AUTO
3417:22454+16	B856  2A43AF  		LHLD	PARAMS	;get drive specified.
3418:22470+7	B859  7E      		MOV	A,M
3419:22477+7	B85A  E61F    		ANI	1FH	;look at lower 5 bits.
3420:22484+5	B85C  3D      		DCR	A	;adjust for (1=A, 2=B) etc.
3421:22489+13	B85D  32D6B9  		STA	EPARAM	;and save for the select routine.
3422:22502+7	B860  FE1E    		CPI	1EH	;check for 'no change' condition.
3423:22509+10	B862  D275B8  		JNC	AUTOSL1	;yes, don't change.
3424:22519+13	B865  3A42AF  		LDA	ACTIVE	;we must change, save currently active
3425:22532+13	B868  32DFB9  		STA	OLDDRV	;drive.
3426:22545+7	B86B  7E      		MOV	A,M	;and save first byte of fcb also.
3427:22552+13	B86C  32E0B9  		STA	AUTOFLAG;this must be non-zero.
3428:22565+7	B86F  E6E0    		ANI	0E0H	;whats this for (bits 6,7 are used for
3429:22572+7	B871  77      		MOV	M,A	;something)?
3430:22579+17	B872  CD45B8  		CALL	SETDSK	;select and log in this drive.
3431:22596+13	B875  3A41AF  	AUTOSL1	LDA	USERNO	;move user number into fcb.
3432:22609+16	B878  2A43AF  		LHLD	PARAMS	;(* upper half of first byte *)
3433:22625+7	B87B  B6      		ORA	M
3434:22632+7	B87C  77      		MOV	M,A
3435:22639+10	B87D  C9      		RET		;and return (all done).
3436:				;
3437:				;   Function to return the current cp/m version number.
3438:				;
3439:22649+7	B87E  3E22    	GETVER	MVI	A,022h	;version 2.2
3440:22656+10	B880  C301AF  		JMP	SETSTAT
3441:				;
3442:				;   Function to reset the disk system.
3443:				;
3444:22666+10	B883  210000  	RSTDSK	LXI	H,0	;clear write protect status and log
3445:22676+16	B886  22ADB9  		SHLD	WRTPRT	;in vector.
3446:22692+16	B889  22AFB9  		SHLD	LOGIN
3447:22708+4	B88C  AF      		XRA	A	;select drive 'A'.
3448:22712+13	B88D  3242AF  		STA	ACTIVE
3449:22725+10	B890  218000  		LXI	H,TBUFF	;setup default dma address.
3450:22735+16	B893  22B1B9  		SHLD	USERDMA
3451:22751+17	B896  CDDAB1  		CALL	DEFDMA
3452:22768+10	B899  C321B8  		JMP	LOGINDRV;now log in drive 'A'.
3453:				;
3454:				;   Function to open a specified file.
3455:				;
3456:22778+17	B89C  CD72B1  	OPENFIL	CALL	CLEARS2	;clear 's2' byte.
3457:22795+17	B89F  CD51B8  		CALL	AUTOSEL	;select proper disk.
3458:22812+10	B8A2  C351B4  		JMP	OPENIT	;and open the file.
3459:				;
3460:				;   Function to close a specified file.
3461:				;
3462:22822+17	B8A5  CD51B8  	CLOSEFIL:CALL	AUTOSEL	;select proper disk.
3463:22839+10	B8A8  C3A2B4  		JMP	CLOSEIT	;and close the file.
3464:				;
3465:				;   Function to return the first occurence of a specified file
3466:				; name. If the first byte of the fcb is '?' then the name will
3467:				; not be checked (get the first entry no matter what).
3468:				;
3469:22849+7	B8AB  0E00    	GETFST	MVI	C,0	;prepare for special search.
3470:22856+4	B8AD  EB      		XCHG
3471:22860+7	B8AE  7E      		MOV	A,M	;is first byte a '?'?
3472:22867+7	B8AF  FE3F    		CPI	'?'
3473:22874+10	B8B1  CAC2B8  		JZ	GETFST1	;yes, just get very first entry (zero length match).
3474:22884+17	B8B4  CDA6B0  		CALL	SETEXT	;get the extension byte from fcb.
3475:22901+7	B8B7  7E      		MOV	A,M	;is it '?'? if yes, then we want
3476:22908+7	B8B8  FE3F    		CPI	'?'	;an entry with a specific 's2' byte.
3477:22915+11+6	B8BA  C472B1  		CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
3478:22926+17	B8BD  CD51B8  		CALL	AUTOSEL	;select proper drive.
3479:22943+7	B8C0  0E0F    		MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
3480:22950+17	B8C2  CD18B3  	GETFST1	CALL	FINDFST	;find an entry and then move it into
3481:22967+10	B8C5  C3E9B1  		JMP	MOVEDIR	;the users dma space.
3482:				;
3483:				;   Function to return the next occurence of a file name.
3484:				;
3485:22977+16	B8C8  2AD9B9  	GETNXT	LHLD	SAVEFCB	;restore pointers. note that no
3486:22993+16	B8CB  2243AF  		SHLD	PARAMS	;other dbos calls are allowed.
3487:23009+17	B8CE  CD51B8  		CALL	AUTOSEL	;no error will be returned, but the
3488:23026+17	B8D1  CD2DB3  		CALL	FINDNXT	;results will be wrong.
3489:23043+10	B8D4  C3E9B1  		JMP	MOVEDIR
3490:				;
3491:				;   Function to delete a file by name.
3492:				;
3493:23053+17	B8D7  CD51B8  	DELFILE	CALL	AUTOSEL	;select proper drive.
3494:23070+17	B8DA  CD9CB3  		CALL	ERAFILE	;erase the file.
3495:23087+10	B8DD  C301B3  		JMP	STSTATUS;set status and return.
3496:				;
3497:				;   Function to execute a sequential read of the specified
3498:				; record number.
3499:				;
3500:23097+17	B8E0  CD51B8  	READSEQ	CALL	AUTOSEL	;select proper drive then read.
3501:23114+10	B8E3  C3BCB5  		JMP	RDSEQ
3502:				;
3503:				;   Function to write the net sequential record.
3504:				;
3505:23124+17	B8E6  CD51B8  	WRTSEQ	CALL	AUTOSEL	;select proper drive then write.
3506:23141+10	B8E9  C3FEB5  		JMP	WTSEQ
3507:				;
3508:				;   Create a file function.
3509:				;
3510:23151+17	B8EC  CD72B1  	FCREATE	CALL	CLEARS2	;clear the 's2' byte on all creates.
3511:23168+17	B8EF  CD51B8  		CALL	AUTOSEL	;select proper drive and get the next
3512:23185+10	B8F2  C324B5  		JMP	GETEMPTY;empty directory space.
3513:				;
3514:				;   Function to rename a file.
3515:				;
3516:23195+17	B8F5  CD51B8  	RENFILE	CALL	AUTOSEL	;select proper drive and then switch
3517:23212+17	B8F8  CD16B4  		CALL	CHGNAMES;file names.
3518:23229+10	B8FB  C301B3  		JMP	STSTATUS
3519:				;
3520:				;   Function to return the login vector.
3521:				;
3522:23239+16	B8FE  2AAFB9  	GETLOG	LHLD	LOGIN
3523:23255+10	B901  C329B9  		JMP	GETPRM1
3524:				;
3525:				;   Function to return the current disk assignment.
3526:				;
3527:23265+13	B904  3A42AF  	GETCRNT	LDA	ACTIVE
3528:23278+10	B907  C301AF  		JMP	SETSTAT
3529:				;
3530:				;   Function to set the dma address.
3531:				;
3532:23288+4	B90A  EB      	PUTDMA	XCHG
3533:23292+16	B90B  22B1B9  		SHLD	USERDMA	;save in our space and then get to
3534:23308+10	B90E  C3DAB1  		JMP	DEFDMA	;the bios with this also.
3535:				;
3536:				;   Function to return the allocation vector.
3537:				;
3538:23318+16	B911  2ABFB9  	GETALOC	LHLD	ALOCVECT
3539:23334+10	B914  C329B9  		JMP	GETPRM1
3540:				;
3541:				;   Function to return the read-only status vector.
3542:				;
3543:23344+16	B917  2AADB9  	GETROV	LHLD	WRTPRT
3544:23360+10	B91A  C329B9  		JMP	GETPRM1
3545:				;
3546:				;   Function to set the file attributes (read-only, system).
3547:				;
3548:23370+17	B91D  CD51B8  	SETATTR	CALL	AUTOSEL	;select proper drive then save attributes.
3549:23387+17	B920  CD3BB4  		CALL	SAVEATTR
3550:23404+10	B923  C301B3  		JMP	STSTATUS
3551:				;
3552:				;   Function to return the address of the disk parameter block
3553:				; for the current drive.
3554:				;
3555:23414+16	B926  2ABBB9  	GETPARM	LHLD	DISKPB
3556:23430+16	B929  2245AF  	GETPRM1	SHLD	STATUS
3557:23446+10	B92C  C9      		RET
3558:				;
3559:				;   Function to get or set the user number. If (E) was (FF)
3560:				; then this is a request to return the current user number.
3561:				; Else set the user number from (E).
3562:				;
3563:23456+13	B92D  3AD6B9  	GETUSER	LDA	EPARAM	;get parameter.
3564:23469+7	B930  FEFF    		CPI	0FFH	;get user number?
3565:23476+10	B932  C23BB9  		JNZ	SETUSER
3566:23486+13	B935  3A41AF  		LDA	USERNO	;yes, just do it.
3567:23499+10	B938  C301AF  		JMP	SETSTAT
3568:23509+7	B93B  E61F    	SETUSER	ANI	1FH	;no, we should set it instead. keep low
3569:23516+13	B93D  3241AF  		STA	USERNO	;bits (0-4) only.
3570:23529+10	B940  C9      		RET
3571:				;
3572:				;   Function to read a random record from a file.
3573:				;
3574:23539+17	B941  CD51B8  	RDRANDOM:CALL	AUTOSEL	;select proper drive and read.
3575:23556+10	B944  C393B7  		JMP	READRAN
3576:				;
3577:				;   Function to compute the file size for random files.
3578:				;
3579:23566+17	B947  CD51B8  	WTRANDOM:CALL	AUTOSEL	;select proper drive and write.
3580:23583+10	B94A  C39CB7  		JMP	WRITERAN
3581:				;
3582:				;   Function to compute the size of a random file.
3583:				;
3584:23593+17	B94D  CD51B8  	FILESIZE:CALL	AUTOSEL	;select proper drive and check file length
3585:23610+10	B950  C3D2B7  		JMP	RANSIZE
3586:				;
3587:				;   Function #37. This allows a program to log off any drives.
3588:				; On entry, set (DE) to contain a word with bits set for those
3589:				; drives that are to be logged off. The log-in vector and the
3590:				; write protect vector will be updated. This must be a M/PM
3591:				; special function.
3592:				;
3593:23620+16	B953  2A43AF  	LOGOFF	LHLD	PARAMS	;get drives to log off.
3594:23636+5	B956  7D      		MOV	A,L	;for each bit that is set, we want
3595:23641+4	B957  2F      		CMA		;to clear that bit in (LOGIN)
3596:23645+5	B958  5F      		MOV	E,A	;and (WRTPRT).
3597:23650+5	B959  7C      		MOV	A,H
3598:23655+4	B95A  2F      		CMA
3599:23659+16	B95B  2AAFB9  		LHLD	LOGIN	;reset the login vector.
3600:23675+4	B95E  A4      		ANA	H
3601:23679+5	B95F  57      		MOV	D,A
3602:23684+5	B960  7D      		MOV	A,L
3603:23689+4	B961  A3      		ANA	E
3604:23693+5	B962  5F      		MOV	E,A
3605:23698+16	B963  2AADB9  		LHLD	WRTPRT
3606:23714+4	B966  EB      		XCHG
3607:23718+16	B967  22AFB9  		SHLD	LOGIN	;and save.
3608:23734+5	B96A  7D      		MOV	A,L	;now do the write protect vector.
3609:23739+4	B96B  A3      		ANA	E
3610:23743+5	B96C  6F      		MOV	L,A
3611:23748+5	B96D  7C      		MOV	A,H
3612:23753+4	B96E  A2      		ANA	D
3613:23757+5	B96F  67      		MOV	H,A
3614:23762+16	B970  22ADB9  		SHLD	WRTPRT	;and save. all done.
3615:23778+10	B973  C9      		RET
3616:				;
3617:				;   Get here to return to the user.
3618:				;
3619:23788+13	B974  3ADEB9  	GOBACK	LDA	AUTO	;was auto select activated?
3620:23801+4	B977  B7      		ORA	A
3621:23805+10	B978  CA91B9  		JZ	GOBACK1
3622:23815+16	B97B  2A43AF  		LHLD	PARAMS	;yes, but was a change made?
3623:23831+10	B97E  3600    		MVI	M,0	;(* reset first byte of fcb *)
3624:23841+13	B980  3AE0B9  		LDA	AUTOFLAG
3625:23854+4	B983  B7      		ORA	A
3626:23858+10	B984  CA91B9  		JZ	GOBACK1
3627:23868+7	B987  77      		MOV	M,A	;yes, reset first byte properly.
3628:23875+13	B988  3ADFB9  		LDA	OLDDRV	;and get the old drive and select it.
3629:23888+13	B98B  32D6B9  		STA	EPARAM
3630:23901+17	B98E  CD45B8  		CALL	SETDSK
3631:23918+16	B991  2A0FAF  	GOBACK1	LHLD	USRSTACK;reset the users stack pointer.
3632:23934+5	B994  F9      		SPHL
3633:23939+16	B995  2A45AF  		LHLD	STATUS	;get return status.
3634:23955+5	B998  7D      		MOV	A,L	;force version 1.4 compatability.
3635:23960+5	B999  44      		MOV	B,H
3636:23965+10	B99A  C9      		RET		;and go back to user.
3637:				;
3638:				;   Function #40. This is a special entry to do random i/o.
3639:				; For the case where we are writing to unused disk space, this
3640:				; space will be zeroed out first. This must be a M/PM special
3641:				; purpose function, because why would any normal program even
3642:				; care about the previous contents of a sector about to be
3643:				; written over.
3644:				;
3645:23975+17	B99B  CD51B8  	WTSPECL	CALL	AUTOSEL	;select proper drive.
3646:23992+7	B99E  3E02    		MVI	A,2	;use special write mode.
3647:23999+13	B9A0  32D5B9  		STA	MODE
3648:24012+7	B9A3  0E00    		MVI	C,0	;set write indicator.
3649:24019+17	B9A5  CD07B7  		CALL	POSITN1	;position the file.
3650:24036+11+6	B9A8  CC03B6  		CZ	WTSEQ1	;and write (if no errors).
3651:24047+10	B9AB  C9      		RET
3652:				;
3653:				;**************************************************************
3654:				;*
3655:				;*     BDOS data storage pool.
3656:				;*
3657:				;**************************************************************
3658:				;
3659:     -	B9AC  E5      	EMPTYFCB:DB	0E5H	;empty directory segment indicator.
3660:     -	B9AD  0000    	WRTPRT	DW	0	;write protect status for all 16 drives.
3661:     -	B9AF  0000    	LOGIN	DW	0	;drive active word (1 bit per drive).
3662:     -	B9B1  8000    	USERDMA	DW	080H	;user's dma address (defaults to 80h).
3663:				;
3664:				;   Scratch areas from parameter block.
3665:				;
3666:     -	B9B3  0000    	SCRATCH1:DW	0	;relative position within dir segment for file (0-3).
3667:     -	B9B5  0000    	SCRATCH2:DW	0	;last selected track number.
3668:     -	B9B7  0000    	SCRATCH3:DW	0	;last selected sector number.
3669:				;
3670:				;   Disk storage areas from parameter block.
3671:				;
3672:     -	B9B9  0000    	DIRBUF	DW	0	;address of directory buffer to use.
3673:     -	B9BB  0000    	DISKPB	DW	0	;contains address of disk parameter block.
3674:     -	B9BD  0000    	CHKVECT	DW	0	;address of check vector.
3675:     -	B9BF  0000    	ALOCVECT:DW	0	;address of allocation vector (bit map).
3676:				;
3677:				;   Parameter block returned from the bios.
3678:				;
3679:     -	B9C1  0000    	SECTORS	DW	0	;sectors per track from bios.
3680:     -	B9C3  00      	BLKSHFT	DB	0	;block shift.
3681:     -	B9C4  00      	BLKMASK	DB	0	;block mask.
3682:     -	B9C5  00      	EXTMASK	DB	0	;extent mask.
3683:     -	B9C6  0000    	DSKSIZE	DW	0	;disk size from bios (number of blocks-1).
3684:     -	B9C8  0000    	DIRSIZE	DW	0	;directory size.
3685:     -	B9CA  0000    	ALLOC0	DW	0	;storage for first bytes of bit map (dir space used).
3686:     -	B9CC  0000    	ALLOC1	DW	0
3687:     -	B9CE  0000    	OFFSET	DW	0	;first usable track number.
3688:     -	B9D0  0000    	XLATE	DW	0	;sector translation table address.
3689:				;
3690:				;
3691:     -	B9D2  00      	CLOSEFLG:DB	0	;close flag (=0ffh is extent written ok).
3692:     -	B9D3  00      	RDWRTFLG:DB	0	;read/write flag (0ffh=read, 0=write).
3693:     -	B9D4  00      	FNDSTAT	DB	0	;filename found status (0=found first entry).
3694:     -	B9D5  00      	MODE	DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
3695:     -	B9D6  00      	EPARAM	DB	0	;storage for register (E) on entry to bdos.
3696:     -	B9D7  00      	RELBLOCK:DB	0	;relative position within fcb of block number written.
3697:     -	B9D8  00      	COUNTER	DB	0	;byte counter for directory name searches.
3698:     -	B9D9  00000000	SAVEFCB	DW	0,0	;save space for address of fcb (for directory searches).
3699:     -	B9DD  00      	BIGDISK	DB	0	;if =0 then disk is > 256 blocks long.
3700:     -	B9DE  00      	AUTO	DB	0	;if non-zero, then auto select activated.
3701:     -	B9DF  00      	OLDDRV	DB	0	;on auto select, storage for previous drive.
3702:     -	B9E0  00      	AUTOFLAG:DB	0	;if non-zero, then auto select changed drives.
3703:     -	B9E1  00      	SAVNXT	DB	0	;storage for next record number to access.
3704:     -	B9E2  00      	SAVEXT	DB	0	;storage for extent number of file.
3705:     -	B9E3  0000    	SAVNREC	DW	0	;storage for number of records in file.
3706:     -	B9E5  0000    	BLKNMBR	DW	0	;block number (physical sector) used within a file or logical sector.
3707:     -	B9E7  0000    	LOGSECT	DW	0	;starting logical (128 byte) sector of block (physical sector).
3708:     -	B9E9  00      	FCBPOS	DB	0	;relative position within buffer for fcb of file of interest.
3709:     -	B9EA  0000    	FILEPOS	DW	0	;files position within directory (0 to max entries -1).
3710:				;
3711:				;   Disk directory buffer checksum bytes. One for each of the
3712:				; 16 possible drives.
3713:				;
3714:     -	B9EC  00000000	CKSUMTBL:DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
3715:				;
3716:				;   Extra space ?
3717:				;
3718:     -	B9FC  00000000		DB	0,0,0,0
3719:				;
3720:				;**************************************************************
3721:				;*
3722:				;*        B I O S   J U M P   T A B L E
3723:				;*
3724:				;**************************************************************
3725:				;
3726:     -	BA00          	BOOT	DS	3	;NOTE WE USE FAKE DESTINATIONS
3727:     -	BA03          	WBOOT	DS	3
3728:     -	BA06          	CONST	DS	3
3729:     -	BA09          	CONIN	DS	3
3730:     -	BA0C          	CONOUT	DS	3
3731:     -	BA0F          	LIST:	DS	3
3732:     -	BA12          	PUNCH	DS	3
3733:     -	BA15          	READER	DS	3
3734:     -	BA18          	HOME	DS	3
3735:     -	BA1B          	SELDSK	DS	3
3736:     -	BA1E          	SETTRK	DS	3
3737:     -	BA21          	SETSEC	DS	3
3738:     -	BA24          	SETDMA	DS	3
3739:     -	BA27          	READ	DS	3
3740:     -	BA2A          	WRITE	DS	3
3741:     -	BA2D          	PRSTAT	DS	3
3742:     -	BA30          	SECTRN	DS	3
3743:				;
3744:				;*
3745:				;******************   E N D   O F   C P / M   *****************
3746:				;*
3747:				
3748:				



Statistics:

     4	passes
     0	jr promotions
   500	symbols
  5632	bytes



Symbol Table:

ACTIVE          AF42      44866
ADDA2HL         B164      45412
ADDHL           A659      42585
ALLOC0          B9CA      47562
ALLOC1          B9CC      47564
ALOCVECT        B9BF      47551
AUTO            B9DE      47582
AUTOFLAG        B9E0      47584
AUTOSEL         B851      47185
AUTOSL1         B875      47221
BACKUP          ADA4      44452
BACKUP1         ADAC      44460
BADLOAD         AB7A      43898
BADSCTR         AC09      44041
BADSEC          ACCA      44234
BADSEL          ACD5      44245
BADSLCT         AC0B      44043
BATCH           ABAB      43947
BATCHFCB        ABAC      43948
BDOSDRV         ACC6      44230
BDOSERR         ACBA      44218
BIGDISK         B9DD      47581
BITMAP          B2A3      45731
BITMAP1         B2B1      45745
BITMAP2         B2D2      45778
BITMAP3         B2F6      45814
BLKMASK         B9C4      47556
BLKNMBR         B9E5      47589
BLKSHFT         B9C3      47555
BOOT            BA00      47616
BS             =08        8
CBASE           A400      41984
CCPSTACK       =ABAB      43947
CDRIVE          ABEF      44015
CHARBUF         AF0E      44814
CHECK           A630      42544
CHECKDIR        B19E      45470
CHECKSUM        B0F7      45303
CHGDRV          ABF0      44016
CHGNAM1         B427      46119
CHGNAMES        B416      46102
CHKBLK          B084      45188
CHKCHAR         AD14      44308
CHKCON          A5C2      42434
CHKDIR1         B1C4      45508
CHKNMBR         B18C      45452
CHKROFL         B144      45380
CHKSUM1         B0FD      45309
CHKVECT         B9BD      47549
CHKWPRT         B154      45396
CKBITMAP        B235      45621
CKBMAP1         B256      45654
CKCON1          AD42      44354
CKCON2          AD45      44357
CKCONSOL        AD23      44323
CKFILPOS        B1F5      45557
CKROF1          B147      45383
CKSUMTBL        B9EC      47596
CLEARBUF        A758      42840
CLEARS2         B172      45426
CLOSE           A4DA      42202
CLOSEFIL        B8A5      47269
CLOSEFLG        B9D2      47570
CLOSEIT         B4A2      46242
CLOSEIT1        B4CD      46285
CLOSEIT2        B4DB      46299
CLOSEIT3        B4E1      46305
CLOSEIT4        B4E8      46312
CLOSEIT5        B4FD      46333
CLOSEIT6        B517      46359
CLOSEIT7        B51F      46367
CMDADR          A7C1      42945
CMDTBL          A710      42768
CMMND1          A782      42882
CMMND2          A798      42904
CNTRLC         =03        3
CNTRLE         =05        5
CNTRLP         =10        16
CNTRLR         =12        18
CNTRLS         =13        19
CNTRLU         =15        21
CNTRLX         =18        24
CNTRLZ         =1A        26
COMBLK          B077      45175
COMFILE         AB83      43907
COMMAND         A75C      42844
COMPRAND        B7A5      47013
CONIN           BA09      47625
CONOUT          BA0C      47628
CONST           BA06      47622
CONVERT         A660      42592
CONVFST         A65E      42590
CONVRT1         A689      42633
CONVRT2         A690      42640
CONVRT3         A696      42646
CONVRT4         A698      42648
CONVRT5         A6A9      42665
CONVRT6         A6AB      42667
CONVRT7         A6AF      42671
CONVRT8         A6B9      42681
COUNTER         B9D8      47576
CR             =0D        13
CREATE          A509      42249
CRLF            A498      42136
CURPOS          AF0C      44812
DE2HL           AF4F      44879
DE2HL1          AF50      44880
DECODE          A7F8      43000
DECODE1         A808      43016
DECODE2         A82A      43050
DECODE3         A833      43059
DECODE4         A83A      43066
DEFDMA          B1DA      45530
DEL            =7F        127
DELBATCH        A5DD      42461
DELETE          A4EF      42223
DELFILE         B8D7      47319
DIRBUF          B9B9      47545
DIRC1           AEE0      44768
DIRCIO          AED4      44756
DIRDMA          B1E0      45536
DIRDMA1         B1E3      45539
DIRECT          A877      43127
DIRECT1         A888      43144
DIRECT2         A88F      43151
DIRECT3         A898      43160
DIRECT4         A8CC      43212
DIRECT5         A8D4      43220
DIRECT6         A8D9      43225
DIRECT7         A90E      43278
DIRECT8         A90F      43279
DIRECT9         A91B      43291
DIRREAD         B1D4      45524
DIRSIZE         B9C8      47560
DIRWRITE        B1C6      45510
DISKPB          B9BB      47547
DISKRO          ACE1      44257
DMASET          A5D8      42456
DOREAD          AFB2      44978
DOWRITE         AFB8      44984
DRECT63         A8F7      43255
DRECT65         A8F9      43257
DSELECT         A854      43092
DSKSEL          A4BD      42173
DSKSIZE         B9C6      47558
EMPTYFCB        B9AC      47532
ENTRY          =05        5
ENTRY1          A4C3      42179
ENTRY2          A4F4      42228
EPARAM          B9D6      47574
ERAFIL1         B3A4      45988
ERAFILE         B39C      45980
ERASE           A91F      43295
ERASE1          A942      43330
ERROR1          AC99      44185
ERROR2          ACA5      44197
ERROR3          ACAB      44203
ERROR4          ACB1      44209
ERROR5          ACB4      44212
EXISTS          AA82      43650
EXTBLK          B05E      45150
EXTBLK1         B071      45169
EXTMASK         B9C5      47557
EXTRACT         A84B      43083
FBASE           AC06      44038
FBASE1          AC11      44049
FCB             ABCD      43981
FCB2HL          B15E      45406
FCBPOS          B9E9      47593
FCBSET          B3FD      46077
FCREATE         B8EC      47340
FF             =0C        12
FILEPOS         B9EA      47594
FILERO          ACDC      44252
FILESIZE        B94D      47437
FINDFST         B318      45848
FINDNXT         B32D      45869
FNDNXT1         B34A      45898
FNDNXT2         B353      45907
FNDNXT3         B373      45939
FNDNXT4         B37C      45948
FNDNXT5         B383      45955
FNDNXT6         B394      45972
FNDSPA1         B3C0      46016
FNDSPA2         B3D1      46033
FNDSPA3         B3EC      46060
FNDSPA4         B3F4      46068
FNDSPACE        B3BE      46014
FNDSTAT         B9D4      47572
FUNCTNS         AC47      44103
GETALOC         B911      47377
GETBACK         AB86      43910
GETBACK1        AB89      43913
GETBLK1         B045      45125
GETBLK2         B053      45139
GETBLK3         B05C      45148
GETBLOCK        B03E      45118
GETCHAR         ACFB      44283
GETCON          AEC8      44744
GETCRNT         B904      47364
GETCSTS         AEFE      44798
GETDSK          A5D0      42448
GETECHO         AD06      44294
GETEMPTY        B524      46372
GETEXT          A6C0      42688
GETEXT1         A6C8      42696
GETEXT2         A6D9      42713
GETEXT3         A6DB      42715
GETEXT4         A6DF      42719
GETEXT5         A6E9      42729
GETEXT6         A6F0      42736
GETEXT7         A6F2      42738
GETEXT8         A701      42753
GETEXT9         A709      42761
GETFST          B8AB      47275
GETFST1         B8C2      47298
GETINP          A539      42297
GETINP1         A596      42390
GETINP2         A5A7      42407
GETINP3         A5AB      42411
GETINP4         A5BA      42426
GETIOB          AEED      44781
GETLOG          B8FE      47358
GETMT1          B546      46406
GETNEXT         B55A      46426
GETNXT          B8C8      47304
GETPARM         B926      47398
GETPRM1         B929      47401
GETRDR          AECE      44750
GETROV          B917      47383
GETS2           B169      45417
GETSETUC        A515      42261
GETUSER         B92D      47405
GETUSR          A513      42259
GETVER          B87E      47230
GETWPRT         B11E      45342
GOBACK          B974      47476
GOBACK1         B991      47505
GTNEXT1         B583      46467
GTNEXT2         B58E      46478
GTNEXT3         B5AC      46508
GTNEXT4         B5AF      46511
GTNEXT5         B5B6      46518
HALT            A7CF      42959
HL2DE           A842      43074
HOME            BA18      47640
HOMEDRV         AFA1      44961
INBUFF          A406      41990
INPOINT         A488      42120
IOBYTE         =03        3
IOERR1          AF05      44805
IORET           AFBB      44987
JUMPHL          AF4A      44874
LF             =0A        10
LIST            BA0F      47631
LOGICAL         B08A      45194
LOGICL1         B090      45200
LOGIN           B9AF      47535
LOGINDRV        B821      47137
LOGOFF          B953      47443
LOGSECT         B9E7      47591
MEM            =30        48
MODE            B9D5      47573
MOREFLS         B17F      45439
MOVE3           A840      43072
MOVECD          A529      42281
MOVEDIR         B1E9      45545
MOVEWORD        B494      46228
NAMEPNT         A48A      42122
NBYTES          ABF1      44017
NEWLINE         ADB1      44465
NEWLN1          ADB9      44473
NFUNCTS        =29        41
NOFILE          A7F0      42992
NONBLANK        A64F      42575
NONE            A7EA      42986
NOSPACE         AA07      43527
NUMCMDS        =06        6
NXENT1          B219      45593
NXENT2          B220      45600
NXENTRY         B205      45573
OFFSET          B9CE      47566
OLDDRV          B9DF      47583
OPEN            A4CB      42187
OPENFCB         A4D0      42192
OPENFIL         B89C      47260
OPENIT          B451      46161
OPENIT1         B45A      46170
OPENIT2         B48B      46219
OUTCHAR         AD48      44360
OUTCHR1         AD62      44386
OUTCHR2         AD79      44409
OUTCON          AD90      44432
OUTCON1         AD96      44438
OUTCRLF         ADC9      44489
OUTFLAG         AF0A      44810
PARAMS          AF43      44867
PATTRN1         A728      42792
PATTRN2         AC00      44032
PLINE           A4A7      42151
PLINE2          A4AC      42156
POSITION        B703      46851
POSITN1         B707      46855
POSITN2         B747      46919
POSITN3         B77F      46975
POSITN4         B784      46980
POSITN5         B78B      46987
PRINT           A48C      42124
PRINTB          A492      42130
PRSTAT          BA2D      47661
PRTERR          ACE5      44261
PRTFLAG         AF0D      44813
PRTMESG         ADD3      44499
PRTSTR          AEF8      44792
PUNCH           BA12      47634
PUTDMA          B90A      47370
RANSIZ1         B7E4      47076
RANSIZ2         B806      47110
RANSIZ3         B80C      47116
RANSIZE         B7D2      47058
RDBUF1          ADEF      44527
RDBUF10         AE70      44656
RDBUF11         AE78      44664
RDBUF12         AE8A      44682
RDBUF13         AE99      44697
RDBUF14         AEA6      44710
RDBUF15         AEA9      44713
RDBUF16         AEBD      44733
RDBUF17         AEC1      44737
RDBUF2          ADF1      44529
RDBUF3          AE16      44566
RDBUF4          AE26      44582
RDBUF5          AE37      44599
RDBUF6          AE48      44616
RDBUF7          AE4E      44622
RDBUF8          AE5F      44639
RDBUF9          AE6B      44651
RDBUFF          ADE1      44513
RDERR           A7DF      42975
RDERROR         A7D9      42969
RDRANDOM        B941      47425
RDREC           A4F9      42233
RDSEQ           B5BC      46524
RDSEQ1          B5C1      46529
RDSEQ2          B5E6      46566
RDSEQ3          B5FB      46587
RDWRTFLG        B9D3      47571
READ            BA27      47655
READER          BA15      47637
READFCB         A4FE      42238
READRAN         B793      46995
READSEQ         B8E0      47328
RELBLOCK        B9D7      47575
RENAM           A50E      42254
RENAME          AA10      43536
RENAME1         AA3F      43583
RENAME2         AA59      43609
RENAME3         AA5E      43614
RENAME4         AA6D      43629
RENAME5         AA73      43635
RENAME6         AA79      43641
RENFILE         B8F5      47349
RESDSK          A4B8      42168
RESETDR         A866      43110
RODISK          AC0D      44045
ROFILE          AC0F      44047
RSTDSK          B883      47235
RTN             AF04      44804
RTNCODE         ABEE      44014
SAMEXT          B307      45831
SAVATR1         B440      46144
SAVE            A9AD      43437
SAVE1           A9D4      43476
SAVE2           A9F1      43505
SAVE3           A9FB      43515
SAVE4           AA01      43521
SAVEATTR        B43B      46139
SAVEFCB         B9D9      47577
SAVEXT          B9E2      47586
SAVNREC         B9E3      47587
SAVNXT          B9E1      47585
SCRATCH1        B9B3      47539
SCRATCH2        B9B5      47541
SCRATCH3        B9B7      47543
SEARCH          A72E      42798
SEARCH1         A733      42803
SEARCH2         A73C      42812
SEARCH3         A74F      42831
SEARCH4         A754      42836
SECTORS         B9C1      47553
SECTRN          BA30      47664
SELDSK          BA1B      47643
SELECT          AF59      44889
SELECT1         AF9D      44957
SETATTR         B91D      47389
SETBIT          B10B      45323
SETCDRV         A51A      42266
SETDIR          B19C      45468
SETDMA          BA24      47652
SETDSK          B845      47173
SETEXT          B0A6      45222
SETFILE         B26B      45675
SETFL1          B275      45685
SETFL2          B288      45704
SETFL3          B28E      45710
SETFL4          B29D      45725
SETHLDE         B0AE      45230
SETIOB          AEF3      44787
SETNREC         B0D2      45266
SETRAN          B80E      47118
SETS2B7         B178      45432
SETSEC          BA21      47649
SETSTAT         AF01      44801
SETTRK          BA1E      47646
SETUSER         B93B      47419
SHIFTL          B104      45316
SHIFTL1         B105      45317
SHIFTR          B0EA      45290
SHIFTR1         B0EB      45291
SHOWIT          AD7F      44415
SLCTERR         AF47      44871
SPACE           A4A2      42146
SRCHFCB         A4E9      42217
SRCHFST         A4DF      42207
SRCHNXT         A4E4      42212
STARTING        AF0B      44811
STATUS          AF45      44869
STBITMAP        B25C      45660
STBMAP1         B264      45668
STDDMA          A5D5      42453
STFILPOS        B1FE      45566
STKAREA        =AF41      44865
STNREC1         B0DE      45278
STRDATA         B0BB      45243
STSTATUS        B301      45825
SUBHL           B195      45461
SYNERR          A609      42505
SYNERR1         A60F      42511
SYNERR2         A622      42530
TAB            =09        9
TBASE          = 100      256
TBUFF          =80        128
TDRIVE         =04        4
TFCB           =5C        92
TRKSEC          AFC3      44995
TRKSEC1         AFD1      45009
TRKSEC2         AFE4      45028
TRKSEC3         AFFA      45050
TRKSEC4         B00F      45071
TYPE            A95D      43357
TYPE1           A974      43380
TYPE2           A977      43383
TYPE3           A987      43399
TYPE4           A9A0      43424
TYPE5           A9A7      43431
UNKNOWN         AAA5      43685
UNKWN0          AB71      43889
UNKWN1          AAC4      43716
UNKWN2          AACD      43725
UNKWN3          AAE1      43745
UNKWN4          AB01      43777
UNKWN5          AB30      43824
UNKWN6          AB3E      43838
UNKWN7          AB43      43843
UNKWN8          AB4F      43855
UNKWN9          AB6B      43883
UPDATE          B401      46081
UPDATE1         B410      46096
UPPER           A530      42288
USER            AA8E      43662
USERDMA         B9B1      47537
USERNO          AF41      44865
USRSTACK        AF0F      44815
VERIFY          A5F5      42485
VERIFY1         A5FD      42493
WBOOT           BA03      47619
WRITE           BA2A      47658
WRITERAN        B79C      47004
WRTPRT          B9AD      47533
WRTPRTD         B12C      45356
WRTREC          A504      42244
WRTSEQ          B8E6      47334
WTRANDOM        B947      47431
WTSEQ           B5FE      46590
WTSEQ1          B603      46595
WTSEQ10         B6D2      46802
WTSEQ11         B6FE      46846
WTSEQ12         B700      46848
WTSEQ2          B63B      46651
WTSEQ3          B648      46664
WTSEQ4          B664      46692
WTSEQ5          B66C      46700
WTSEQ6          B66E      46702
WTSEQ7          B68C      46732
WTSEQ8          B69A      46746
WTSEQ9          B6BB      46779
WTSEQ99         B6DF      46815
WTSPECL         B99B      47515
XLATE           B9D0      47568
YESNO           A952      43346
